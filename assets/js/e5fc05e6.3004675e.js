"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[998],{4137:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>N});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(n),N=l,c=m["".concat(s,".").concat(N)]||m[N]||u[N]||r;return n?a.createElement(c,i(i({ref:t},d),{},{components:n})):a.createElement(c,i({ref:t},d))}));function N(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1872:(e,t,n)=>{n.d(t,{m:()=>r});var a=n(7294);const l="leadText_qzwo",r=e=>{let{content:t}=e;return a.createElement(a.Fragment,null,a.createElement("p",{id:l},t))}},5827:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=n(7462),l=(n(7294),n(4137)),r=n(1872);const i={id:"sfmc-sql-null-functions",title:"SFMC SQL NULL Functions",sidebar_label:"Null Functions",description:"IS NULL, or IS NOT NULL, that is the question. Ways of working with NULL values in SFMC SQL.",image:"img/og/og-image-sql-null-functions.png",tags:["Marketing Cloud","SQL"]},o=void 0,s={unversionedId:"sql/sfmc-sql-null-functions",id:"sql/sfmc-sql-null-functions",title:"SFMC SQL NULL Functions",description:"IS NULL, or IS NOT NULL, that is the question. Ways of working with NULL values in SFMC SQL.",source:"@site/docs/sql/sfmc-sql-null-functions.mdx",sourceDirName:"sql",slug:"/sql/sfmc-sql-null-functions",permalink:"/docs/sql/sfmc-sql-null-functions",draft:!1,editUrl:"https://github.com/MateuszDabrowski/mateuszdabrowski.pl/edit/master/docs/sql/sfmc-sql-null-functions.mdx",tags:[{label:"Marketing Cloud",permalink:"/docs/tags/marketing-cloud"},{label:"SQL",permalink:"/docs/tags/sql"}],version:"current",lastUpdatedBy:"Mateusz D\u0105browski",lastUpdatedAt:1657131299,formattedLastUpdatedAt:"Jul 6, 2022",frontMatter:{id:"sfmc-sql-null-functions",title:"SFMC SQL NULL Functions",sidebar_label:"Null Functions",description:"IS NULL, or IS NOT NULL, that is the question. Ways of working with NULL values in SFMC SQL.",image:"img/og/og-image-sql-null-functions.png",tags:["Marketing Cloud","SQL"]},sidebar:"docs",previous:{title:"Aggregate Functions",permalink:"/docs/sql/sfmc-sql-aggregate-functions"},next:{title:"Style Guide",permalink:"/docs/sql/sfmc-sql-style-guide"}},p={},d=[{value:"NULL",id:"null",level:2},{value:"NULL with standard SQL Functions",id:"null-with-standard-sql-functions",level:3},{value:"NULL with relational operators",id:"null-with-relational-operators",level:3},{value:"NULL with conditional operators",id:"null-with-conditional-operators",level:3},{value:"NULL with logical operators",id:"null-with-logical-operators",level:3},{value:"AND operator",id:"and-operator",level:4},{value:"OR operator",id:"or-operator",level:4},{value:"NULL with aggregate functions",id:"null-with-aggregate-functions",level:3},{value:"IS NULL",id:"is-null",level:2},{value:"ISNULL",id:"isnull",level:2},{value:"COALESCE",id:"coalesce",level:2},{value:"NULLIF",id:"nullif",level:2}],u={toc:d};function m(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)(r.m,{content:"IS NULL, or IS NOT NULL, that is the question. Ways of working with NULL values in SFMC SQL.",mdxType:"LeadText"}),(0,l.kt)("p",null,"NULL is a fickle beast, and for the people not accustomed to how it works in SQL, it can create many problems (read: incorrect data output). This is especially true for those coming from nullish-friendly languages (like SSJS). Let's jump into the details."),(0,l.kt)("h2",{id:"null"},"NULL"),(0,l.kt)("p",null,"Like in other languages, NULL is a placeholder that marks an absent (unknown) value. Unlike in other languages (like SSJS), it can be used in any data type. You can have ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," Date (datetime) , ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," Number (int), ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," Text (nvarchar) or ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," Boolean."),(0,l.kt)("p",null,"Also, unlike in some other languages, SQL doesn't support a ",(0,l.kt)("em",{parentName:"p"},"default")," nullish coalescing. In simpler words, it means that empty string (",(0,l.kt)("inlineCode",{parentName:"p"},"''"),") or zero (",(0,l.kt)("inlineCode",{parentName:"p"},"0"),") are not equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),". It makes sense when you treat ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," as an unknown value - unknown is not equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,l.kt)("h3",{id:"null-with-standard-sql-functions"},"NULL with standard SQL Functions"),(0,l.kt)("p",null,"Because ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," is unknown, if you try to do any standard operation on the NULL (like adding an integer, or ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-string-functions#concat"},"concatenating")," it with a string), it will return unknown (",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql",metastring:'{2-3} title="\u274c Functions with NULLs"',"{2-3}":!0,title:'"\u274c',Functions:!0,with:!0,'NULLs"':!0},"SELECT\n      1 + NULL               AS MathFunctionWithNull    -- Outputs NULL\n    , CONCAT('Hello ', NULL) AS StringFunctionWithNull  -- Outputs NULL\n")),(0,l.kt)("h3",{id:"null-with-relational-operators"},"NULL with relational operators"),(0,l.kt)("p",null,"The fun doesn't stop there - When you try to make any ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-where#basic-operators"},"comparision")," with ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),", it will fail, because it is a check against an unknown value. Or, to be more specific, the comparison will evaluate to ",(0,l.kt)("inlineCode",{parentName:"p"},"FALSE"),", impacting your output."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql",metastring:'{4-6} title="\u274c Comparisons with NULLs"',"{4-6}":!0,title:'"\u274c',Comparisons:!0,with:!0,'NULLs"':!0},"SELECT SubscriberKey\nFROM DataExtension\nWHERE\n    NullablePurchaseCount > 0\n    AND NullableProductName != 'T-Shirt'\n    AND EmailAddress != NULL\n")),(0,l.kt)("p",null,"In the example above, all three comparisons in the ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-where"},(0,l.kt)("inlineCode",{parentName:"a"},"WHERE"))," statement will return ",(0,l.kt)("inlineCode",{parentName:"p"},"FALSE")," for ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),"s and the query will not output any rows."),(0,l.kt)("p",null,"Let's check why, step by step:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"NullablePurchaseCount > 0")," - The rows with a value (be it ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"10"),") are evaluated normally. The rows with ",(0,l.kt)("inlineCode",{parentName:"li"},"NULL")," (absent value) evaluate as ",(0,l.kt)("inlineCode",{parentName:"li"},"FALSE")," and are removed from the output."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"NullableProductName != 'T-Shirt'")," - The rows with a value (be it ",(0,l.kt)("inlineCode",{parentName:"li"},"''"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"'Hoodie'")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"'T-Shirt'"),") are evaluated normally. The rows with ",(0,l.kt)("inlineCode",{parentName:"li"},"NULL")," (absent value) evaluate as ",(0,l.kt)("inlineCode",{parentName:"li"},"FALSE")," and are removed from the output."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"EmailAddress != NULL")," - Regardless of the ",(0,l.kt)("inlineCode",{parentName:"li"},"EmailAddress")," value, because we are comparing it to ",(0,l.kt)("inlineCode",{parentName:"li"},"NULL"),", check for every row evaluate to ",(0,l.kt)("inlineCode",{parentName:"li"},"FALSE")," and therefore is dropped from the output.")),(0,l.kt)("h3",{id:"null-with-conditional-operators"},"NULL with conditional operators"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," gets even more problematic when you want to work with ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-where#in-shorthand"},(0,l.kt)("inlineCode",{parentName:"a"},"IN"),"/",(0,l.kt)("inlineCode",{parentName:"a"},"NOT IN"))," or ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-where#between-shorthand"},(0,l.kt)("inlineCode",{parentName:"a"},"BETWEEN"),"/",(0,l.kt)("inlineCode",{parentName:"a"},"NOT IN BETWEEN")),"."),(0,l.kt)("p",null,"When you use ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," as one of the values searched by ",(0,l.kt)("inlineCode",{parentName:"p"},"IN")," shorthand, it will be ignored, and no rows with ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," in the checked column will be outputted for this condition."),(0,l.kt)("p",null,"When you use ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," with the other shorthands (",(0,l.kt)("inlineCode",{parentName:"p"},"NOT IN"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"BETWEEN")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"NOT IN BETWEEN"),"), this condition will have no results."),(0,l.kt)("h3",{id:"null-with-logical-operators"},"NULL with logical operators"),(0,l.kt)("p",null,"When you are building a boolean logic with ",(0,l.kt)("inlineCode",{parentName:"p"},"AND"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"OR")," operators (be it in ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-where"},(0,l.kt)("inlineCode",{parentName:"a"},"WHERE"))," or in ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-case"},(0,l.kt)("inlineCode",{parentName:"a"},"CASE")),") treat ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," as ",(0,l.kt)("inlineCode",{parentName:"p"},"FALSE"),"."),(0,l.kt)("h4",{id:"and-operator"},"AND operator"),(0,l.kt)("p",null,"When you have two booleans or expressions connected by the ",(0,l.kt)("inlineCode",{parentName:"p"},"AND")," operator, it will only evaluate to ",(0,l.kt)("inlineCode",{parentName:"p"},"TRUE")," if both are ",(0,l.kt)("inlineCode",{parentName:"p"},"TRUE"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Boolean or Expression"),(0,l.kt)("th",{parentName:"tr",align:null},"Boolean or Expression"),(0,l.kt)("th",{parentName:"tr",align:null},"Result"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"TRUE"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL")))),(0,l.kt)("h4",{id:"or-operator"},"OR operator"),(0,l.kt)("p",null,"When you have two booleans or expressions connected by the ",(0,l.kt)("inlineCode",{parentName:"p"},"OR")," operator, it will evaluate to ",(0,l.kt)("inlineCode",{parentName:"p"},"TRUE")," if at least one is ",(0,l.kt)("inlineCode",{parentName:"p"},"TRUE"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Boolean or Expression"),(0,l.kt)("th",{parentName:"tr",align:null},"Boolean or Expression"),(0,l.kt)("th",{parentName:"tr",align:null},"Result"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"TRUE"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"TRUE"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"TRUE"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"TRUE"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"TRUE"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"TRUE"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"FALSE"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL"),(0,l.kt)("td",{parentName:"tr",align:null},"NULL")))),(0,l.kt)("h3",{id:"null-with-aggregate-functions"},"NULL with aggregate functions"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-aggregate-functions"},"Aggregate functions")," just ignore ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," values. Calculating average? ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," will not be taken into consideration at all - which can scew your output a lot."),(0,l.kt)("p",null,"The only exception is ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-aggregate-functions#count"},(0,l.kt)("inlineCode",{parentName:"a"},"COUNT"))," that has specific ",(0,l.kt)("inlineCode",{parentName:"p"},"*")," argument for counting rows with ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),"."),(0,l.kt)("p",null,"Ok, we discussed a lot of ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," problems. Now it's time to solve them with dedicated ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," functions."),(0,l.kt)("h2",{id:"is-null"},"IS NULL"),(0,l.kt)("p",null,"Firstly, let's cover how we can recognize whether a ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," is a ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),". Using standard ",(0,l.kt)("inlineCode",{parentName:"p"},"="),"/",(0,l.kt)("inlineCode",{parentName:"p"},"!=")," operators won't work, but you can do it easily with dedicated ",(0,l.kt)("inlineCode",{parentName:"p"},"IS NULL"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"IS NOT NULL")," operators:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql",metastring:'{3} title="Subscribers with Email Address"',"{3}":!0,title:'"Subscribers',with:!0,Email:!0,'Address"':!0},"SELECT SubscriberKey\nFROM DataExtension\nWHERE EmailAddress IS NOT NULL\n")),(0,l.kt)("p",null,"Because comparison operators don't work, if you are building filters on nullable values, you might have to query defensively:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql",metastring:'{5} title="Subscribers with small amount of purchases"',"{5}":!0,title:'"Subscribers',with:!0,small:!0,amount:!0,of:!0,'purchases"':!0},"SELECT SubscriberKey\nFROM DataExtension\nWHERE\n    PurchaseCount < 5\n    OR PurchaseCount IS NULL\n")),(0,l.kt)("p",null,"Assuming ",(0,l.kt)("inlineCode",{parentName:"p"},"PurchaseCount")," is a nullable field, should you use only ",(0,l.kt)("inlineCode",{parentName:"p"},"PurchaseCount < 5"),", you wouldn't see the rows with the ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," in that column. Adding another condition that checks explicitly for ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," solves that."),(0,l.kt)("p",null,"However, there are other methods - dedicated shorthands of the universally helpful ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-case"},(0,l.kt)("inlineCode",{parentName:"a"},"CASE"))," statement. Let's check them."),(0,l.kt)("h2",{id:"isnull"},"ISNULL"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"ISNULL")," function is the first line of defence against the ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),"s. It takes two arguments, checks the first one, and returns it if it is not ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),". Else, it returns the second. Perfect for creating a fallback value for nullable columns."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql",metastring:'{3} title="Subscribers with small amount of purchases"',"{3}":!0,title:'"Subscribers',with:!0,small:!0,amount:!0,of:!0,'purchases"':!0},"SELECT SubscriberKey\nFROM DataExtension\nWHERE ISNULL(PurchaseCount, 0) < 5\n")),(0,l.kt)("p",null,"Now the filter will check whether ",(0,l.kt)("inlineCode",{parentName:"p"},"PurchaseCount")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),". If not, it will use its value. If yes, it will consider it a zero for the conditional check."),(0,l.kt)("p",null,"The second argument doesn't have to be a standard value. It can also be a column. Just make sure it is not nullable, or..."),(0,l.kt)("h2",{id:"coalesce"},"COALESCE"),(0,l.kt)("p",null,"If a single fallback provided by ",(0,l.kt)("inlineCode",{parentName:"p"},"ISNULL")," is not enough, the ",(0,l.kt)("inlineCode",{parentName:"p"},"COALESCE")," function lets you provide multiple. ",(0,l.kt)("inlineCode",{parentName:"p"},"COALESCE")," will return the first argument that is not ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),". However, if all are ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," - the final outcome will also be ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql",metastring:'{3,5} title="Find Subscribers with at least one available address for a direct mail"',"{3,5}":!0,title:'"Find',Subscribers:!0,with:!0,at:!0,least:!0,one:!0,available:!0,address:!0,for:!0,a:!0,direct:!0,'mail"':!0},"SELECT\n      SubscriberKey\n    , COALESCE(HomeAddress, WorkAddress, ParentAddress) AS AvailableAddress\nFROM DataExtension\nWHERE COALESCE(HomeAddress, WorkAddress, ParentAddress) IS NOT NULL\n")),(0,l.kt)("admonition",{title:"You Should Know",type:"note"},(0,l.kt)("p",{parentName:"admonition"},(0,l.kt)("inlineCode",{parentName:"p"},"COALESCE")," is perfect for creating concatenated fields where you are not sure if all parts will be available, as it lets you control the number of spaces between elements:"),(0,l.kt)("pre",{parentName:"admonition"},(0,l.kt)("code",{parentName:"pre",className:"language-sql",metastring:'title="Calculate FullName with nullable MiddleName"',title:'"Calculate',FullName:!0,with:!0,nullable:!0,'MiddleName"':!0},"SELECT CONCAT(FirstName, ' ', COALESCE(MiddleName + ' ', ''), LastName) AS FullName\n"))),(0,l.kt)("h2",{id:"nullif"},"NULLIF"),(0,l.kt)("p",null,"Finally, there is the ",(0,l.kt)("inlineCode",{parentName:"p"},"NULLIF")," function that returns ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL")," if two provided arguments are equal or the first argument if they are different:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql",metastring:'{4} title="Pulls WorkEmailAddress value only if it is different from general EmailAddress"',"{4}":!0,title:'"Pulls',WorkEmailAddress:!0,value:!0,only:!0,if:!0,it:!0,is:!0,different:!0,from:!0,general:!0,'EmailAddress"':!0},"SELECT\n      SubscriberKey\n    , EmailAddress\n    , NULLIF(WorkEmailAddress, EmailAddress) AS WorkEmailAddress\n")),(0,l.kt)("p",null,"I personally find the standard ",(0,l.kt)("a",{parentName:"p",href:"/docs/sql/sfmc-sql-case#iif-shorthand"},(0,l.kt)("inlineCode",{parentName:"a"},"IIF"))," shorthand much more readable and user-friendly, despite being slightly longer than dedicated ",(0,l.kt)("inlineCode",{parentName:"p"},"NULLIF"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql",metastring:'{4} title="Pulls WorkEmailAddress value only if it is different from general Email Address with IIF"',"{4}":!0,title:'"Pulls',WorkEmailAddress:!0,value:!0,only:!0,if:!0,it:!0,is:!0,different:!0,from:!0,general:!0,Email:!0,Address:!0,with:!0,'IIF"':!0},"SELECT\n      SubscriberKey\n    , EmailAddress\n    , IIF(WorkEmailAddress = EmailAddress, NULL, EmailAddress) AS WorkEmailAddress\n")))}m.isMDXComponent=!0}}]);