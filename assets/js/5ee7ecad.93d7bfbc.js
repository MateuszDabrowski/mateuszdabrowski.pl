"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[840],{3180:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var i=t(5893),s=t(1151),r=t(1872);const o={id:"sfmc-sql-string-functions",title:"SFMC SQL String Functions",sidebar_label:"String Functions",description:"Take control over strings with built-in SQL functions. Let the query do the job.",image:"img/og/og-image-sql-string-functions.png",tags:["Marketing Cloud","SQL"]},a=void 0,l={id:"sql/sfmc-sql-string-functions",title:"SFMC SQL String Functions",description:"Take control over strings with built-in SQL functions. Let the query do the job.",source:"@site/docs/sql/sfmc-sql-string-functions.mdx",sourceDirName:"sql",slug:"/sql/sfmc-sql-string-functions",permalink:"/docs/sql/sfmc-sql-string-functions",draft:!1,unlisted:!1,editUrl:"https://github.com/MateuszDabrowski/mateuszdabrowski.pl/edit/master/docs/sql/sfmc-sql-string-functions.mdx",tags:[{label:"Marketing Cloud",permalink:"/docs/tags/marketing-cloud"},{label:"SQL",permalink:"/docs/tags/sql"}],version:"current",lastUpdatedBy:"Mateusz D\u0105browski",lastUpdatedAt:1708642896,formattedLastUpdatedAt:"Feb 22, 2024",frontMatter:{id:"sfmc-sql-string-functions",title:"SFMC SQL String Functions",sidebar_label:"String Functions",description:"Take control over strings with built-in SQL functions. Let the query do the job.",image:"img/og/og-image-sql-string-functions.png",tags:["Marketing Cloud","SQL"]},sidebar:"docs",previous:{title:"Like",permalink:"/docs/sql/sfmc-sql-like"},next:{title:"Date Functions",permalink:"/docs/sql/sfmc-sql-date-functions"}},c={},d=[{value:"LEFT &amp; RIGHT",id:"left--right",level:2},{value:"LEN",id:"len",level:2},{value:"CHARINDEX",id:"charindex",level:2},{value:"PATINDEX",id:"patindex",level:2},{value:"CONCAT",id:"concat",level:2},{value:"LTRIM, RTRIM and TRIM",id:"ltrim-rtrim-and-trim",level:2},{value:"NEWID",id:"newid",level:2},{value:"LOWER, UPPER and Title Case",id:"lower-upper-and-title-case",level:2},{value:"FORMAT with Strings",id:"format-with-strings",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.m,{content:"Take control over strings with built-in SQL functions. Let the query do the job."}),"\n",(0,i.jsx)(n.p,{children:"Salesforce Marketing Cloud SQL implementation does not support user-defined functions. There are, however, multiple built-in functions that are useful on a day-to-day basis when working with queries."}),"\n",(0,i.jsx)(n.p,{children:"Here, I will cover only selected string functions that I find most useful for Marketing Automation purposes. They will help you change the values, split and concatenate them, or find elements within."}),"\n",(0,i.jsx)(n.admonition,{title:"You Should Know",type:"note",children:(0,i.jsx)(n.p,{children:"All string functions in SQL use a 1-based index instead of 0-based indexing known from, for example, JavaScript. The first character starts at index 1. It is crucial to provide the correct value to the arguments and correctly interpret the results."})}),"\n",(0,i.jsx)(n.h2,{id:"left--right",children:"LEFT & RIGHT"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"LEFT"})," and ",(0,i.jsx)(n.code,{children:"RIGHT"})," functions allow you to cut down the string to just part of it."]}),"\n",(0,i.jsx)(n.p,{children:"Both require source value and the number of characters to return."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:'title="LEFT and RIGHT can work both on strings as well as on other data types"',children:"SELECT\n      LEFT(FirstName, 1)    AS FirstNameInitialLetter\n    , RIGHT(FirstName, 1)   AS FirstNameEndingLetter\n    , LEFT(s.DateJoined, 3) AS MonthJoined\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Both those functions can be beneficial to clean and streamline your data by themselves, but their real power becomes evident when you mix them with ",(0,i.jsx)(n.a,{href:"#charindex",children:(0,i.jsx)(n.code,{children:"CHARINDEX"})})," for content-aware cuts."]}),"\n",(0,i.jsx)(n.h2,{id:"len",children:"LEN"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"LEN"})," function returns a count of characters in the value."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:'{3} title="If you use Salesforce Contact ID as Subscriber Key, use LEN to find invalid records quickly"',children:"SELECT SubscriberKey\nFROM _Subscribers\nWHERE LEN(SubscriberKey) != 18\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It is less useful for segmentation but awesome for various administrative purposes. Apart from the example above, I highly recommend checking how this function combines with ",(0,i.jsxs)(n.a,{href:"/docs/sql/sfmc-sql-numeric-functions#min-and-max",children:[(0,i.jsx)(n.code,{children:"MAX"})," function"]}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"charindex",children:"CHARINDEX"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"CHARINDEX"})," function lets you find if and where one string is in another. You pass the value you want to find, the value in which you wish to search and, optionally, the index from which you want to start the search."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:"title=\"Search for 'Manager' in the JobTitle column starting with the first index\"",children:'CHARINDEX("Manager", JobTitle, 1)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["I used the optional starting index in the example above, but you will not be using it in most cases. The ",(0,i.jsx)(n.code,{children:"CHARINDEX"})," defaults to starting from the beginning so that we can write the above line shorter as ",(0,i.jsx)(n.code,{children:'CHARINDEX("Manager", JobTitle)'}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The function returns one of the three possible values:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"NULL - if either value to find or searched value is NULL"}),"\n",(0,i.jsx)(n.li,{children:"0 - if the value to find is not within the searched value"}),"\n",(0,i.jsx)(n.li,{children:"any other digit - the index where the value to find starts within the searched value - if there are multiple occurrences, the result will show the starting index of just the first one."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["By default, ",(0,i.jsx)(n.code,{children:"CHARINDEX"})," in SFMC is case-insensitive in its searches. You can, however, enforce case sensitivity by adding ",(0,i.jsx)(n.code,{children:"COLLATE"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:'title="Case sensitive CHARINDEX search - note lack of a comma between the value and COLLATE"',children:'CHARINDEX("Manager", JobTitle COLLATE Latin1_General_CS_AS)\n'})}),"\n",(0,i.jsxs)(n.admonition,{title:"You Should Know",type:"note",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"CHARINDEX"})," is especially useful when combined with ",(0,i.jsx)(n.a,{href:"/docs/sql/sfmc-sql-case#conditional-values-with-case",children:(0,i.jsx)(n.code,{children:"CASE"})})," and ",(0,i.jsx)(n.a,{href:"#left--right",children:(0,i.jsx)(n.code,{children:"LEFT"})}),"/",(0,i.jsx)(n.a,{href:"#left--right",children:(0,i.jsx)(n.code,{children:"RIGHT"})})," functions, as it allows for smart string operations:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:'{3} title="Dynamically pull part of the Institution Name value"',children:"SELECT\n      CASE\n        WHEN CHARINDEX(' ', InstitutionName) > 0 THEN LEFT(InstitutionName, CHARINDEX(' ', InstitutionName) - 1)\n        ELSE InstitutionName\n      END AS InstitutionType\nFROM Accounts\n"})}),(0,i.jsxs)(n.p,{children:["The above query checks whether there is a space within the ",(0,i.jsx)(n.code,{children:"InstitutionName"})," value and if yes - it captures only the first word. Think about all the educational institution names with ",(0,i.jsx)(n.code,{children:"University of..."}),", ",(0,i.jsx)(n.code,{children:"School of..."})," - by taking only the first part, we can create a new simplified data point categorising records by type."]})]}),"\n",(0,i.jsx)(n.h2,{id:"patindex",children:"PATINDEX"}),"\n",(0,i.jsxs)(n.p,{children:["While ",(0,i.jsx)(n.a,{href:"#charindex",children:(0,i.jsx)(n.code,{children:"CHARINDEX"})})," is great for searching the position of a specific string in a value, ",(0,i.jsx)(n.code,{children:"PATINDEX"})," gives you even more power by supporting the wildcard patterns used with ",(0,i.jsx)(n.a,{href:"/docs/sql/sfmc-sql-like",children:(0,i.jsx)(n.code,{children:"LIKE"})})," operator:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Wildcards & Operators"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"%"})}),(0,i.jsx)(n.td,{children:"Zero, one or more characters"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"_"})}),(0,i.jsx)(n.td,{children:"Exactly one character"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[]"})}),(0,i.jsx)(n.td,{children:"Any single character from the list specified inside"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"-"})}),(0,i.jsxs)(n.td,{children:["Range operator for ",(0,i.jsx)(n.code,{children:"[]"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"^"})}),(0,i.jsxs)(n.td,{children:["Exclusion operator for ",(0,i.jsx)(n.code,{children:"[]"})]})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["To learn more about specific wildcards and advanced operators, check out the ",(0,i.jsxs)(n.a,{href:"/docs/sql/sfmc-sql-like",children:[(0,i.jsx)(n.code,{children:"LIKE"})," guide"]}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:'title="Broad C-Suite hunt with PATINDEX"',children:"PATINDEX('%C_O%', JobTitle)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["While wildcards give ",(0,i.jsx)(n.code,{children:"PATINDEX"})," an edge over ",(0,i.jsx)(n.a,{href:"#charindex",children:(0,i.jsx)(n.code,{children:"CHARINDEX"})}),", it misses one feature of the latter - an optional argument for starting the search from a specific string. Either can be better depending on the use case at hand."]}),"\n",(0,i.jsx)(n.h2,{id:"concat",children:"CONCAT"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"CONCAT"})," function allows you to join two or more strings together."]}),"\n",(0,i.jsx)(n.p,{children:"You can use it on both existing values pulled from source data extension, as well as on custom strings and digits added directly in the query. In most cases, you will mix both."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:'{4} title="Perfect for preparing your data for personalization"',children:"SELECT\n      SubscriberKey\n    , EmailAddress\n    , CONCAT(FirstName, ' ', LastName) AS FullName\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can concatenate any number of strings by just adding them comma-separated."}),"\n",(0,i.jsxs)(n.admonition,{title:"You Should Know",type:"note",children:[(0,i.jsx)(n.p,{children:"In many cases, you might see concatenation done with the plus sign notation."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:'{4} title="Same as above, but with the plus notation"',children:"SELECT\n      SubscriberKey\n    , EmailAddress\n    , FirstName + ' ' + LastName AS FullName\n"})}),(0,i.jsx)(n.p,{children:"It might seem cleaner, but there are two downsides to this method:"}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["With the plus notation, if at least one provided value is ",(0,i.jsx)(n.code,{children:"NULL"}),", the outcome becomes ",(0,i.jsx)(n.code,{children:"NULL"}),". ",(0,i.jsx)(n.code,{children:"CONCAT"})," function treats such values as empty strings."]}),"\n",(0,i.jsxs)(n.li,{children:["If you want to join a string with a date type value, you need to use ",(0,i.jsx)(n.a,{href:"/docs/sql/sfmc-sql-conversion-functions#cast--convert",children:(0,i.jsx)(n.code,{children:"CONVERT"})}),", but ",(0,i.jsx)(n.code,{children:"CONCAT"})," will do the implicit conversion for you."]}),"\n"]})]}),"\n",(0,i.jsx)(n.h2,{id:"ltrim-rtrim-and-trim",children:"LTRIM, RTRIM and TRIM"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"LTRIM"})," and ",(0,i.jsx)(n.code,{children:"RTRIM"})," functions allow you to quickly clean your data by deleting unneeded spaces from the beginning or the end of the provided string."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:'title="Noone likes useless whitespace in their database"',children:"SELECT\n      LTRIM('   data from webform ')        AS CleanLeftSide    /* Output: 'data from webform ' */\n    , RTRIM('   data from webform ')        AS CleanRightSide   /* Output: '   data from webform' */\n    , TRIM('   data from webform ')         AS CleanBothSides   /* Output: 'data from webform' */\n"})}),"\n",(0,i.jsx)(n.h2,{id:"newid",children:"NEWID"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"NEWID"})," function creates a pseudorandom identifier in the form of a 36-character string GUID (RFC4122 compliant)."]}),"\n",(0,i.jsxs)(n.p,{children:["The output structure is the same as for the SSJS ",(0,i.jsx)(n.code,{children:"Platform.Function.GUID()"})," or AMPScript ",(0,i.jsx)(n.code,{children:"GUID()"})," functions - five alphanumerical strings joined by hyphens."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:'{1} title="Returns GUID in the form of XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"',children:"SELECT NEWID() AS UniqueID\n"})}),"\n",(0,i.jsx)(n.h2,{id:"lower-upper-and-title-case",children:"LOWER, UPPER and Title Case"}),"\n",(0,i.jsx)(n.p,{children:"When working with SQL, you will frequently encounter dirty data that needs some cleaning before being leveraged for personalisation in marketing sends. One of the frequent issues is inconsistent letter cases, especially on self-filled data points like first and last names coming from lead forms."}),"\n",(0,i.jsxs)(n.p,{children:["Thankfully, SQL can clean up such data with built-in ",(0,i.jsx)(n.code,{children:"LOWER"})," and ",(0,i.jsx)(n.code,{children:"UPPER"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:"{3-4}",children:"SELECT\n      'DIRTY Data' AS SampleData\n    , LOWER('DIRTY Data') AS Lowercase /* Output: 'dirty data' */\n    , UPPER('DIRTY Data') AS Uppercase /* Output: 'DIRTY DATA' */\n"})}),"\n",(0,i.jsx)(n.p,{children:"However, there is no out-of-the-box function for Proper Case - a popular requirement, especially around names and titles. The basic solution for single-word strings is straightforward:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",metastring:"{3}",children:"SELECT\n      FirstName /* Output: 'MATEUSZ' */\n    , UPPER(LEFT(FirstName, 1)) + LOWER(RIGHT(FirstName, LEN(FirstName) - 1)) AS Propercase /* Output: 'Mateusz' */\n"})}),"\n",(0,i.jsxs)(n.p,{children:["However, it will not work with complex (like names with a hyphen in the middle) or multi-word values. The standard SQL solution - User Defined Function - doesn't work in a limited Salesforce Marketing Cloud SQL environment. The alternative - using ",(0,i.jsx)(n.a,{href:"#charindex",children:(0,i.jsx)(n.code,{children:"CHARINDEX"})}),"/",(0,i.jsx)(n.a,{href:"#patindex",children:(0,i.jsx)(n.code,{children:"PATINDEX"})})," to find each word - gets awful as soon as you hit three words and more."]}),"\n",(0,i.jsxs)(n.p,{children:["Recommended approach? Either clean the data before ingestion to SFMC or do it directly in the email with the built-in AMPScript ",(0,i.jsx)(n.code,{children:"ProperCase"})," function."]}),"\n",(0,i.jsx)(n.h2,{id:"format-with-strings",children:"FORMAT with Strings"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"FORMAT"})," function lets you quickly change the data into a different format. In Salesforce Marketing Cloud, it is especially useful, as you cannot create your functions. ",(0,i.jsx)(n.code,{children:"FORMAT"})," might save you massive headaches."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"FORMAT"})," works only with datetime and numeric values. Why I'm writing about it here then? Because you can use ",(0,i.jsx)(n.a,{href:"/docs/sql/sfmc-sql-conversion-functions#cast--convert",children:(0,i.jsx)(n.code,{children:"CONVERT"})})," function to change some of your strings into compliant data types. Consider changing string dates into datetime or phone numbers into integers to format them easily. Check out ",(0,i.jsxs)(n.a,{href:"/docs/sql/sfmc-sql-date-functions#format-with-dates",children:[(0,i.jsx)(n.code,{children:"FORMAT"})," with Dates"]})," and ",(0,i.jsxs)(n.a,{href:"/docs/sql/sfmc-sql-numeric-functions#format-with-numbers",children:[(0,i.jsx)(n.code,{children:"FORMAT"})," with Numbers"]})," for more information. The outcome of formatting both number and date types with this function is a string."]})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1872:(e,n,t)=>{t.d(n,{m:()=>r});t(7294);const i="leadText_qzwo";var s=t(5893);const r=e=>{let{content:n}=e;return(0,s.jsx)(s.Fragment,{children:(0,s.jsx)("p",{id:i,children:n})})}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var i=t(7294);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);