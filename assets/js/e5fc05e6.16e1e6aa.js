"use strict";(self.webpackChunkmd=self.webpackChunkmd||[]).push([[998],{5083:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var l=s(5893),i=s(1151),t=s(1872);const r={id:"sfmc-sql-null-functions",title:"SFMC SQL NULL Functions",sidebar_label:"Null Functions",description:"IS NULL, or IS NOT NULL, that is the question. Ways of working with NULL values in SFMC SQL.",image:"img/og/og-image-sql-null-functions.png",tags:["Marketing Cloud","SQL"]},o=void 0,a={id:"sql/sfmc-sql-null-functions",title:"SFMC SQL NULL Functions",description:"IS NULL, or IS NOT NULL, that is the question. Ways of working with NULL values in SFMC SQL.",source:"@site/docs/sql/sfmc-sql-null-functions.mdx",sourceDirName:"sql",slug:"/sql/sfmc-sql-null-functions",permalink:"/docs/sql/sfmc-sql-null-functions",draft:!1,unlisted:!1,editUrl:"https://github.com/MateuszDabrowski/mateuszdabrowski.pl/edit/master/docs/sql/sfmc-sql-null-functions.mdx",tags:[{label:"Marketing Cloud",permalink:"/docs/tags/marketing-cloud"},{label:"SQL",permalink:"/docs/tags/sql"}],version:"current",lastUpdatedBy:"Mateusz D\u0105browski",lastUpdatedAt:1657131299,formattedLastUpdatedAt:"Jul 6, 2022",frontMatter:{id:"sfmc-sql-null-functions",title:"SFMC SQL NULL Functions",sidebar_label:"Null Functions",description:"IS NULL, or IS NOT NULL, that is the question. Ways of working with NULL values in SFMC SQL.",image:"img/og/og-image-sql-null-functions.png",tags:["Marketing Cloud","SQL"]},sidebar:"docs",previous:{title:"Aggregate Functions",permalink:"/docs/sql/sfmc-sql-aggregate-functions"},next:{title:"Style Guide",permalink:"/docs/sql/sfmc-sql-style-guide"}},d={},c=[{value:"NULL",id:"null",level:2},{value:"NULL with standard SQL Functions",id:"null-with-standard-sql-functions",level:3},{value:"NULL with relational operators",id:"null-with-relational-operators",level:3},{value:"NULL with conditional operators",id:"null-with-conditional-operators",level:3},{value:"NULL with logical operators",id:"null-with-logical-operators",level:3},{value:"AND operator",id:"and-operator",level:4},{value:"OR operator",id:"or-operator",level:4},{value:"NULL with aggregate functions",id:"null-with-aggregate-functions",level:3},{value:"IS NULL",id:"is-null",level:2},{value:"ISNULL",id:"isnull",level:2},{value:"COALESCE",id:"coalesce",level:2},{value:"NULLIF",id:"nullif",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.m,{content:"IS NULL, or IS NOT NULL, that is the question. Ways of working with NULL values in SFMC SQL."}),"\n",(0,l.jsx)(n.p,{children:"NULL is a fickle beast, and for the people not accustomed to how it works in SQL, it can create many problems (read: incorrect data output). This is especially true for those coming from nullish-friendly languages (like SSJS). Let's jump into the details."}),"\n",(0,l.jsx)(n.h2,{id:"null",children:"NULL"}),"\n",(0,l.jsxs)(n.p,{children:["Like in other languages, NULL is a placeholder that marks an absent (unknown) value. Unlike in other languages (like SSJS), it can be used in any data type. You can have ",(0,l.jsx)(n.code,{children:"NULL"})," Date (datetime) , ",(0,l.jsx)(n.code,{children:"NULL"})," Number (int), ",(0,l.jsx)(n.code,{children:"NULL"})," Text (nvarchar) or ",(0,l.jsx)(n.code,{children:"NULL"})," Boolean."]}),"\n",(0,l.jsxs)(n.p,{children:["Also, unlike in some other languages, SQL doesn't support a ",(0,l.jsx)(n.em,{children:"default"})," nullish coalescing. In simpler words, it means that empty string (",(0,l.jsx)(n.code,{children:"''"}),") or zero (",(0,l.jsx)(n.code,{children:"0"}),") are not equal to ",(0,l.jsx)(n.code,{children:"NULL"}),". It makes sense when you treat ",(0,l.jsx)(n.code,{children:"NULL"})," as an unknown value - unknown is not equal to ",(0,l.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,l.jsx)(n.h3,{id:"null-with-standard-sql-functions",children:"NULL with standard SQL Functions"}),"\n",(0,l.jsxs)(n.p,{children:["Because ",(0,l.jsx)(n.code,{children:"NULL"})," is unknown, if you try to do any standard operation on the NULL (like adding an integer, or ",(0,l.jsx)(n.a,{href:"/docs/sql/sfmc-sql-string-functions#concat",children:"concatenating"})," it with a string), it will return unknown (",(0,l.jsx)(n.code,{children:"NULL"}),"):"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",metastring:'{2-3} title="\u274c Functions with NULLs"',children:"SELECT\n      1 + NULL               AS MathFunctionWithNull    -- Outputs NULL\n    , CONCAT('Hello ', NULL) AS StringFunctionWithNull  -- Outputs NULL\n"})}),"\n",(0,l.jsx)(n.h3,{id:"null-with-relational-operators",children:"NULL with relational operators"}),"\n",(0,l.jsxs)(n.p,{children:["The fun doesn't stop there - When you try to make any ",(0,l.jsx)(n.a,{href:"/docs/sql/sfmc-sql-where#basic-operators",children:"comparision"})," with ",(0,l.jsx)(n.code,{children:"NULL"}),", it will fail, because it is a check against an unknown value. Or, to be more specific, the comparison will evaluate to ",(0,l.jsx)(n.code,{children:"FALSE"}),", impacting your output."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",metastring:'{4-6} title="\u274c Comparisons with NULLs"',children:"SELECT SubscriberKey\nFROM DataExtension\nWHERE\n    NullablePurchaseCount > 0\n    AND NullableProductName != 'T-Shirt'\n    AND EmailAddress != NULL\n"})}),"\n",(0,l.jsxs)(n.p,{children:["In the example above, all three comparisons in the ",(0,l.jsx)(n.a,{href:"/docs/sql/sfmc-sql-where",children:(0,l.jsx)(n.code,{children:"WHERE"})})," statement will return ",(0,l.jsx)(n.code,{children:"FALSE"})," for ",(0,l.jsx)(n.code,{children:"NULL"}),"s and the query will not output any rows."]}),"\n",(0,l.jsx)(n.p,{children:"Let's check why, step by step:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"NullablePurchaseCount > 0"})," - The rows with a value (be it ",(0,l.jsx)(n.code,{children:"0"})," or ",(0,l.jsx)(n.code,{children:"10"}),") are evaluated normally. The rows with ",(0,l.jsx)(n.code,{children:"NULL"})," (absent value) evaluate as ",(0,l.jsx)(n.code,{children:"FALSE"})," and are removed from the output."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"NullableProductName != 'T-Shirt'"})," - The rows with a value (be it ",(0,l.jsx)(n.code,{children:"''"}),", ",(0,l.jsx)(n.code,{children:"'Hoodie'"})," or ",(0,l.jsx)(n.code,{children:"'T-Shirt'"}),") are evaluated normally. The rows with ",(0,l.jsx)(n.code,{children:"NULL"})," (absent value) evaluate as ",(0,l.jsx)(n.code,{children:"FALSE"})," and are removed from the output."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"EmailAddress != NULL"})," - Regardless of the ",(0,l.jsx)(n.code,{children:"EmailAddress"})," value, because we are comparing it to ",(0,l.jsx)(n.code,{children:"NULL"}),", check for every row evaluate to ",(0,l.jsx)(n.code,{children:"FALSE"})," and therefore is dropped from the output."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"null-with-conditional-operators",children:"NULL with conditional operators"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"NULL"})," gets even more problematic when you want to work with ",(0,l.jsxs)(n.a,{href:"/docs/sql/sfmc-sql-where#in-shorthand",children:[(0,l.jsx)(n.code,{children:"IN"}),"/",(0,l.jsx)(n.code,{children:"NOT IN"})]})," or ",(0,l.jsxs)(n.a,{href:"/docs/sql/sfmc-sql-where#between-shorthand",children:[(0,l.jsx)(n.code,{children:"BETWEEN"}),"/",(0,l.jsx)(n.code,{children:"NOT IN BETWEEN"})]}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["When you use ",(0,l.jsx)(n.code,{children:"NULL"})," as one of the values searched by ",(0,l.jsx)(n.code,{children:"IN"})," shorthand, it will be ignored, and no rows with ",(0,l.jsx)(n.code,{children:"NULL"})," in the checked column will be outputted for this condition."]}),"\n",(0,l.jsxs)(n.p,{children:["When you use ",(0,l.jsx)(n.code,{children:"NULL"})," with the other shorthands (",(0,l.jsx)(n.code,{children:"NOT IN"}),", ",(0,l.jsx)(n.code,{children:"BETWEEN"})," and ",(0,l.jsx)(n.code,{children:"NOT IN BETWEEN"}),"), this condition will have no results."]}),"\n",(0,l.jsx)(n.h3,{id:"null-with-logical-operators",children:"NULL with logical operators"}),"\n",(0,l.jsxs)(n.p,{children:["When you are building a boolean logic with ",(0,l.jsx)(n.code,{children:"AND"}),"/",(0,l.jsx)(n.code,{children:"OR"})," operators (be it in ",(0,l.jsx)(n.a,{href:"/docs/sql/sfmc-sql-where",children:(0,l.jsx)(n.code,{children:"WHERE"})})," or in ",(0,l.jsx)(n.a,{href:"/docs/sql/sfmc-sql-case",children:(0,l.jsx)(n.code,{children:"CASE"})}),") treat ",(0,l.jsx)(n.code,{children:"NULL"})," as ",(0,l.jsx)(n.code,{children:"FALSE"}),"."]}),"\n",(0,l.jsx)(n.h4,{id:"and-operator",children:"AND operator"}),"\n",(0,l.jsxs)(n.p,{children:["When you have two booleans or expressions connected by the ",(0,l.jsx)(n.code,{children:"AND"})," operator, it will only evaluate to ",(0,l.jsx)(n.code,{children:"TRUE"})," if both are ",(0,l.jsx)(n.code,{children:"TRUE"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"Boolean or Expression | Boolean or Expression | Result"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["| - | -\nTRUE | TRUE | ",(0,l.jsx)(n.strong,{children:"TRUE"}),"\nTRUE | FALSE | FALSE\nTRUE | NULL | NULL\nFALSE | TRUE | FALSE\nFALSE | FALSE | FALSE\nFALSE | NULL | NULL\nNULL | TRUE | NULL\nNULL | FALSE | NULL\nNULL | NULL | NULL"]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"or-operator",children:"OR operator"}),"\n",(0,l.jsxs)(n.p,{children:["When you have two booleans or expressions connected by the ",(0,l.jsx)(n.code,{children:"OR"})," operator, it will evaluate to ",(0,l.jsx)(n.code,{children:"TRUE"})," if at least one is ",(0,l.jsx)(n.code,{children:"TRUE"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"Boolean or Expression | Boolean or Expression | Result"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["| - | -\nTRUE | TRUE | ",(0,l.jsx)(n.strong,{children:"TRUE"}),"\nTRUE | FALSE | ",(0,l.jsx)(n.strong,{children:"TRUE"}),"\nTRUE | NULL | ",(0,l.jsx)(n.strong,{children:"TRUE"}),"\nFALSE | TRUE | ",(0,l.jsx)(n.strong,{children:"TRUE"}),"\nFALSE | FALSE | FALSE\nFALSE | NULL | NULL\nNULL | TRUE | ",(0,l.jsx)(n.strong,{children:"TRUE"}),"\nNULL | FALSE | NULL\nNULL | NULL | NULL"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"null-with-aggregate-functions",children:"NULL with aggregate functions"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.a,{href:"/docs/sql/sfmc-sql-aggregate-functions",children:"Aggregate functions"})," just ignore ",(0,l.jsx)(n.code,{children:"NULL"})," values. Calculating average? ",(0,l.jsx)(n.code,{children:"NULL"})," will not be taken into consideration at all - which can scew your output a lot."]}),"\n",(0,l.jsxs)(n.p,{children:["The only exception is ",(0,l.jsx)(n.a,{href:"/docs/sql/sfmc-sql-aggregate-functions#count",children:(0,l.jsx)(n.code,{children:"COUNT"})})," that has specific ",(0,l.jsx)(n.code,{children:"*"})," argument for counting rows with ",(0,l.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["Ok, we discussed a lot of ",(0,l.jsx)(n.code,{children:"NULL"})," problems. Now it's time to solve them with dedicated ",(0,l.jsx)(n.code,{children:"NULL"})," functions."]}),"\n",(0,l.jsx)(n.h2,{id:"is-null",children:"IS NULL"}),"\n",(0,l.jsxs)(n.p,{children:["Firstly, let's cover how we can recognize whether a ",(0,l.jsx)(n.code,{children:"NULL"})," is a ",(0,l.jsx)(n.code,{children:"NULL"}),". Using standard ",(0,l.jsx)(n.code,{children:"="}),"/",(0,l.jsx)(n.code,{children:"!="})," operators won't work, but you can do it easily with dedicated ",(0,l.jsx)(n.code,{children:"IS NULL"}),"/",(0,l.jsx)(n.code,{children:"IS NOT NULL"})," operators:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",metastring:'{3} title="Subscribers with Email Address"',children:"SELECT SubscriberKey\nFROM DataExtension\nWHERE EmailAddress IS NOT NULL\n"})}),"\n",(0,l.jsx)(n.p,{children:"Because comparison operators don't work, if you are building filters on nullable values, you might have to query defensively:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",metastring:'{5} title="Subscribers with small amount of purchases"',children:"SELECT SubscriberKey\nFROM DataExtension\nWHERE\n    PurchaseCount < 5\n    OR PurchaseCount IS NULL\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Assuming ",(0,l.jsx)(n.code,{children:"PurchaseCount"})," is a nullable field, should you use only ",(0,l.jsx)(n.code,{children:"PurchaseCount < 5"}),", you wouldn't see the rows with the ",(0,l.jsx)(n.code,{children:"NULL"})," in that column. Adding another condition that checks explicitly for ",(0,l.jsx)(n.code,{children:"NULL"})," solves that."]}),"\n",(0,l.jsxs)(n.p,{children:["However, there are other methods - dedicated shorthands of the universally helpful ",(0,l.jsx)(n.a,{href:"/docs/sql/sfmc-sql-case",children:(0,l.jsx)(n.code,{children:"CASE"})})," statement. Let's check them."]}),"\n",(0,l.jsx)(n.h2,{id:"isnull",children:"ISNULL"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"ISNULL"})," function is the first line of defence against the ",(0,l.jsx)(n.code,{children:"NULL"}),"s. It takes two arguments, checks the first one, and returns it if it is not ",(0,l.jsx)(n.code,{children:"NULL"}),". Else, it returns the second. Perfect for creating a fallback value for nullable columns."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",metastring:'{3} title="Subscribers with small amount of purchases"',children:"SELECT SubscriberKey\nFROM DataExtension\nWHERE ISNULL(PurchaseCount, 0) < 5\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Now the filter will check whether ",(0,l.jsx)(n.code,{children:"PurchaseCount"})," is ",(0,l.jsx)(n.code,{children:"NULL"}),". If not, it will use its value. If yes, it will consider it a zero for the conditional check."]}),"\n",(0,l.jsx)(n.p,{children:"The second argument doesn't have to be a standard value. It can also be a column. Just make sure it is not nullable, or..."}),"\n",(0,l.jsx)(n.h2,{id:"coalesce",children:"COALESCE"}),"\n",(0,l.jsxs)(n.p,{children:["If a single fallback provided by ",(0,l.jsx)(n.code,{children:"ISNULL"})," is not enough, the ",(0,l.jsx)(n.code,{children:"COALESCE"})," function lets you provide multiple. ",(0,l.jsx)(n.code,{children:"COALESCE"})," will return the first argument that is not ",(0,l.jsx)(n.code,{children:"NULL"}),". However, if all are ",(0,l.jsx)(n.code,{children:"NULL"})," - the final outcome will also be ",(0,l.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",metastring:'{3,5} title="Find Subscribers with at least one available address for a direct mail"',children:"SELECT\n      SubscriberKey\n    , COALESCE(HomeAddress, WorkAddress, ParentAddress) AS AvailableAddress\nFROM DataExtension\nWHERE COALESCE(HomeAddress, WorkAddress, ParentAddress) IS NOT NULL\n"})}),"\n",(0,l.jsxs)(n.admonition,{title:"You Should Know",type:"note",children:[(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"COALESCE"})," is perfect for creating concatenated fields where you are not sure if all parts will be available, as it lets you control the number of spaces between elements:"]}),(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",metastring:'title="Calculate FullName with nullable MiddleName"',children:"SELECT CONCAT(FirstName, ' ', COALESCE(MiddleName + ' ', ''), LastName) AS FullName\n"})})]}),"\n",(0,l.jsx)(n.h2,{id:"nullif",children:"NULLIF"}),"\n",(0,l.jsxs)(n.p,{children:["Finally, there is the ",(0,l.jsx)(n.code,{children:"NULLIF"})," function that returns ",(0,l.jsx)(n.code,{children:"NULL"})," if two provided arguments are equal or the first argument if they are different:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",metastring:'{4} title="Pulls WorkEmailAddress value only if it is different from general EmailAddress"',children:"SELECT\n      SubscriberKey\n    , EmailAddress\n    , NULLIF(WorkEmailAddress, EmailAddress) AS WorkEmailAddress\n"})}),"\n",(0,l.jsxs)(n.p,{children:["I personally find the standard ",(0,l.jsx)(n.a,{href:"/docs/sql/sfmc-sql-case#iif-shorthand",children:(0,l.jsx)(n.code,{children:"IIF"})})," shorthand much more readable and user-friendly, despite being slightly longer than dedicated ",(0,l.jsx)(n.code,{children:"NULLIF"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",metastring:'{4} title="Pulls WorkEmailAddress value only if it is different from general Email Address with IIF"',children:"SELECT\n      SubscriberKey\n    , EmailAddress\n    , IIF(WorkEmailAddress = EmailAddress, NULL, EmailAddress) AS WorkEmailAddress\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}},1872:(e,n,s)=>{s.d(n,{m:()=>t});s(7294);const l="leadText_qzwo";var i=s(5893);const t=e=>{let{content:n}=e;return(0,i.jsx)(i.Fragment,{children:(0,i.jsx)("p",{id:l,children:n})})}},1151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>r});var l=s(7294);const i={},t=l.createContext(i);function r(e){const n=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),l.createElement(t.Provider,{value:n},e.children)}}}]);