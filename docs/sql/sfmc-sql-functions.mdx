---
id: sfmc-sql-functions
title: SFMC SQL Functions
sidebar_label: SQL Functions
description: Writing in Progress
draft: true
---

import { LeadText } from '../../src/components/LeadText.js';

<LeadText content='Writing in Progress' />

Saleforce Marketing Cloud SQL implementation does not support user-defined functions. There are, however, multiple built-in functions that are really useful on day-to-day basis when working with queries. Here, I will cover only selected list of them, that I find most useful for Marketing Automation purposes.

## String Manipulation

First category of SQL functions is for working with string values. Those functions will help you change the values, split or concatenate them, or find elements within.

:::note You Should Know

All string functions in SQL are using 1-based index instead of 0-based indexing known from, for example, JavaScript. First character starts at index 1. It is important for both providing correct value to parameters, as well as correctly interpreting the results.

:::

### CHARINDEX

`CHARINDEX` function lets you find if and where one string is in another. You pass the value you want to find, the value in which you want to search and, optionally, the index of from which you want to start the search.

```sql title="Search for 'Manager' in JobTitle column starting with first index"
CHARINDEX("Manager", JobTitle, 1)
```

In the example above I used the optional starting index, but in most cases you will not be using it. The `CHARINDEX` defaults to starting from the beginning, so the above line can be written shorter as `CHARINDEX("Manager", JobTitle)`.

The function returns one three possible values:

1. NULL - if either value to find or searched value is NULL
2. 0 - if the value to find is not within the searched value
3. any other digit - the index where the value to find starts within the searched value - if there are multiple ocurrences, the result will shown starting index of just the first one.

By default, `CHARINDEX` in SFMC is case-insensitive in its searches. You can, however, enforce case-sensitivity by adding `COLLATE`:

```sql title="Case sensitive CHARINDEX search - note lack of comma between the value and COLLATE"
CHARINDEX("Manager", JobTitle COLLATE Latin1_General_CS_AS)
```

:::note You Should Know

`CHARINDEX` is especially useful when combined with [`LEFT`](#left), [`RIGHT`](#right) and [`SUBSTRING`](#substring) functions, as it allows for smart string operations:

```sql
```

:::

### CONCAT

`CONCAT` function allows you to join two or more strings together.

You can use it on both existing values pulled from source data extension, as well as on custom strings and digits added directly in the query. In most cases, you will mix both.

```sql {4} title="Perfect to prepare your data for personalization"
SELECT
    SubscriberKey,
    EmailAddress,
    CONCAT(FirstName, ' ', LastName) AS FullName
```

You can concatenate any number of strings by just adding them comma separated.

### FORMAT with Strings

`FORMAT` function lets you quickly change the data into a different format. In Salesforce Marketing Cloud it is especially useful, as you cannot create your own functions. `FORMAT` might save you huge headaches.

The `FORMAT` works only with datetime and numeric values and requires:

1. Value to be formatted (can be column, string or function)
2. Format specifier to be applied
3. Optionally - ISO culture code

Why I'm writing about `FORMAT` here, when I just wrote that it doesn't work with Strings? Because you can use [`CONVERT`](#convert) function to change some of your strings into working data types. Consider changing string dates into datetime or phone numbers into integers to format them easily. Check out [`FORMAT` with Dates](#format-with-dates) and [`FORMAT` with Numbers](#format-with-numbers) for more information.

## Date Manipulation

### FORMAT with Dates

I already highlighted most important information about `FORMAT` function when covering String Manipulation (check [here](#format-with-strings)), so now is time to dive into use cases.

First that comes to mind when dealing with US-centric SFMC is to change the date format. For personalization. For comparision between system and imported dates outside of the query. For preparing data that will be exported to external system with specific format requirements.

```sql {2-4} title="Instead of creating complex AMPScript logic to adapt dates, just format them"
SELECT
    FORMAT(CONVERT(DATETIME, '10/30/2020'), 'd', 'en-GB') AS DateOrderedProperly,
    FORMAT(GETUTCDATE(), 'dd/MM/yyyy') AS TodayCustomFormat,
    FORMAT(DateJoined, 'D', 'sa-IN') AS DateExpandedIndian

```

In the example above, first two `FORMAT` functions return date in the same format - `30/10/2020`. First using manually provided one. Second by taking current UTC date. The last line outputs `Freitag, 7. Februar 2020`. Use case? For example run it with [`CASE`](sfmc-sql-case) to change your short date into language-personalized long date.

#### Supported date formats

In the above example you could see three different format specifiers used to manipulate the date, but there is much more avaialble. You can find the most useful below:

| Format specifier | Description | Example (for US culture) |
| -- | -- | -- |
| 'd' | Short date | 10/30/2020 |
| 'D' | Long date | Friday, October 30, 2020 |
| 'm'/'M' | Month Day | October 30 |
| 'y'/'Y' | Year Month | October 2020 |
| 't' | Short time | 2:15 PM |
| 'T' | Long time | 2:15:30 PM |
| 'g' | General short time | 10/30/2020 2:15 PM |
| 'G' | General long time | 10/30/2020 2:15:30 PM |
| 'f' | Full short time | Friday, October 30, 2020 2:15 PM |
| 'F' | Full long time | Friday, October 30, 2020 2:15:30 PM |
| 'r'/'R' | RFC1123 | Fri, 30 Oct 2020 14:15:30 GMT |

Just as highlighted in the table header - the examples are for the SFMC default US culture formating. If you add another culture code as third parameter, the outcome will be different, as various countries have different defaults of elements order.

Of course, you are not limited to the formats shown above. Whenever you want something different, you can create your own format by just providing full pattern instead of short specifier by using those:

| Format specifier | Description | Example (for US culture) |
| -- | -- | -- |
| 'd' | Day of the month | 1 |
| 'dd' | Zero-based day of the month | 01 |
| 'ddd' | Abbreviated day of the month | Mon |
| 'dddd' | Full day of the month | Monday |
| 'M' | Month | 1 |
| 'MM' | Zero-based month | 01 |
| 'MMM' | Abbreviated month | Jan |
| 'MMMM' | Full month | January |
| 'yy' | Last two digits of the year | 20 |
| 'yyyy' | Four digits year | 2020 |
| 'h' | Hour (12-hour clock) | 1 |
| 'hh' | Zero-based hour (12-hour clock) | 01 |
| 'tt' | AM/PM designator | AM |
| 'H' | Hour (24-hour clock) | 13 |
| 'HH' | Zero-based hour (24-hour clock) | 01 |
| 'm' | Minute | 1 |
| 'mm' | Zero-based minute | 01 |
| 's' | Seconds | 1 |
| 'ss' | Zero-based seconds | 01 |


## Numeric Manipulation

### FORMAT with Numbers
