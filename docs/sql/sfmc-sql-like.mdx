---
id: sfmc-sql-like
title: SFMC SQL Like
sidebar_label: Like
description: Work in progress
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { LeadText } from '../../src/components/LeadText.js';

<LeadText content='Work in progress' />

`LIKE` operator allows you to leverage wildcards to search for matching records based on value fragment. You may use it in the [`SELECT CASE`](sfmc-sql-select#like-in-case) and [`WHERE`](sfmc-sql-where) statements.

In [`SELECT`](sfmc-sql-select#like-in-case) think about normalizing and categorizing data. In [`WHERE`](sfmc-sql-where) - about filtering with just a part of the value (for example email domain in `EmailAddress` field) or with a single element within multi picklist (for instance finding one value within the comma-separated list of all purchased products).

There are two levels of `LIKE` usage. First is focused on two basic character wildcards and is very strightforward. The second uses full potential of group operator. Let's go through both with practical examples.

## LIKE with Wildcard

There are two basic wildcards available in `LIKE`:

Wildcard | Description
-- | --
`%` | Zero, one or more characters
`_` | Exactly one character

### % Wildcard

The `%` symbol allows you to match zero, one or more characters within your `LIKE` search.

For example, you can search for `%@mateuszdabrowski.pl` domain in `EmailAddress` to get all contacts with an email address ending with `@mateuszdabrowski.pl`.

You can change this filter to `%@mateuszdabrowski.%`. With the second wildcard at the end, it will be looking for any email address that contains `@mateuszdabrowski.` but may have more text on either side of it. It will capture all emails ending with `@mateuszdabrowski.pl` domain just as the previous filter, but also match those with `@mateuszdabrowski.com`, `@mateuszdabrowski.sfmc.eu` and other top level domains.

<Tabs
    defaultValue='where'
    values={[
        {label: 'WHERE', value: 'where'},
        {label: 'SELECT', value: 'select'},
    ]}
>
<TabItem value='where'>


```sql {5} title="All subscribers that have an email address ending with 'mateuszdabrowski.pl' domain"
SELECT
    SubscriberKey,
    EmailAddress
FROM _Subscribers
WHERE EmailAddress LIKE '%@%mateuszdabrowski.pl'
```

In the above example I used two wildcards - one before and one just after `@` symbol. This will allow to not only catch contacts in `@mateuszdabrowski.pl` domain, but also any subdomain, like `@dev.mateuszdabrowski.pl`.

In the marketing automation world, however, `LIKE` operator is especially useful for selecting contacts based on the multi picklist columns. Consider `ActiveSubscriptions` field that can have any combination of values `Phone`, `TV`, `Internet`.

Suppose you would like to select all contacts with active phone subscription. In that case, you shouldn't use [equality operator](sfmc-sql-where#equality) (`WHERE ActiveSubscription = 'Phone'`), as it would return only contacts that have just this one subscription. Some of your customers might, however, have multiple (phone and tv or phone and internet plans). For SQL, a field containing `'Phone'` is not equal with the one having a value of `'Phone', Internet'`. `LIKE` operator is here to save the day.

```sql {5} title="All subscribers that have at least Phone subscription"
SELECT
    SubscriberKey,
    EmailAddress
FROM MasterSubscriberDE
WHERE ActiveSubscription LIKE '%Phone%'
```

</TabItem>
<TabItem value='select'>

```sql {4} title="Categorize your database into either Internal or External records based on email domain"
SELECT
    SubscriberKey,
    CASE
        WHEN EmailAddress LIKE '%@%mateuszdabrowski.pl' THEN 'Internal'
        ELSE 'External'
    END AS ContactType
FROM _Subscribers
```

In the above example I used two wildcards - one before and one just after `@` symbol. This will allow to not only catch contacts in `@mateuszdabrowski.pl` domain, but also any subdomain, like `@dev.mateuszdabrowski.pl`.

</TabItem>
</Tabs>

:::note You Should Know

Always be sure to check whether you apply the wildcards correctly. Popular error is to have either too narrow or too wide scope of your filter. A common issue is lack of `%` operator in the end or beginning of the searched string. For your query, it means that the value should end there.

For example `WHERE EmailAddress LIKE '@gmail.com'` should provide you zero results, as it would be looking for exactly the `@gmail.com` value in the `EmailAddress` field - without any characters before the `@` symbol.

:::

### _ Wildcard

Another wildcard working with `LIKE` is the underscore `_`. It is much simpler, as all it does it pretending to be any single character.

Let's consider a scenario, where you have a multipicklist field containg comma-separated product IDs. For example, a customer with three recommended products might have a value `1,14,27`. The system codes single digit values to subscriptions, and two digit codes to various product categories. Let's use it in the query.

<Tabs
    defaultValue='where'
    values={[
        {label: 'WHERE', value: 'where'},
        {label: 'SELECT', value: 'select'},
    ]}
>
<TabItem value='where'>


```sql {6-9} title="All subscribers with at least one subscription product in their recommendations"
SELECT
    SubscriberKey,
    EmailAddress,
    RecommendedProducts
FROM EcommerceUpsellDE
WHERE RecommendedProducts LIKE '_'
    OR RecommendedProducts LIKE '_,%'
    OR RecommendedProducts LIKE '%,_,%'
    OR RecommendedProducts LIKE '%,_'
```

In the query above we are filtering our database with `RecommendedProducts` field. To add a contact to our segment, in four steps we check if at least one condition is true:

</TabItem>
<TabItem value='select'>

```sql {5-8} title="Create boolean field from a multipicklist one to split database on recommendation type"
SELECT
    SubscriberKey,
    EmailAddress,
    CASE
        WHEN RecommendedProducts LIKE '_' THEN 'True'
        WHEN RecommendedProducts LIKE '_,%' THEN 'True'
        WHEN RecommendedProducts LIKE '%,_,%' THEN 'True'
        WHEN RecommendedProducts LIKE '_,%' THEN 'True'
        ELSE 'False'
    END AS IsSubscriptionRecommended
FROM EcommerceUpsellDE
```

In the query above we are creating new boolean field that will tell us whether the contact has at least one subscription product in their recommended lists. Great for personalized communication emphasizing this recommendation. We do this by assigning value `True` if at least one of four steps evaluates to true:

</TabItem>
</Tabs>

1. If the record has exactly one recommended product that has a single digit code (subscription)
2. If the record has multiple recommended products and the first one is single digit (subscription)
3. If the record has multiple recommended products and one in the middle is single digit (subscription)
4. If the record has multiple recommended products and the last one is single digit (subscription)

## LIKE with Group

There is also a group operator `[]` for `LIKE` statements. It allows you to create even more complex conditions:

Advanced Operator | Description
-- | --
`[]` | Any single character from the list specified inside
`-` | Range operator for `[]`
`^` | Exclusion operator for `[]`

### [] Operator

The group operator `[]` allows you to provide a list of characters that you want to find a match for.

For example, consider the previous example with a field containing multiple IDs of your subscription and standard products. The field stores subscriptions in a form of single digit product IDs. First four IDs are related to Premium subscriptions. IDs from 5 to 9 are Standard subscriptions.

<Tabs
    defaultValue='where'
    values={[
        {label: 'WHERE', value: 'where'},
        {label: 'SELECT', value: 'select'},
    ]}
>
<TabItem value='where'>

If we would like to output only the Premium subscriptions, we would have to create a separate filter for each ID.


```sql {6-14} title="Thus approach would require 16 lines to cover the use case"
SELECT
    SubscriberKey,
    EmailAddress,
    RecommendedProducts
FROM EcommerceUpsellDE
WHERE RecommendedProducts LIKE '1'
    OR RecommendedProducts LIKE '1,%'
    OR RecommendedProducts LIKE '%,1,%'
    OR RecommendedProducts LIKE '%,1'
    OR RecommendedProducts LIKE '2'
    OR RecommendedProducts LIKE '2,%'
    OR RecommendedProducts LIKE '%,2,%'
    OR RecommendedProducts LIKE '%,2'
    ...
```

With group, we can optimize it. A lot.

```sql {6-9} title="Same outcome with just 4 lines"
SELECT
    SubscriberKey,
    EmailAddress,
    RecommendedProducts
FROM EcommerceUpsellDE
WHERE RecommendedProducts LIKE '[1234]'
    OR RecommendedProducts LIKE '[1234],%'
    OR RecommendedProducts LIKE '%,[1234],%'
    OR RecommendedProducts LIKE '%,[1234]'
```

</TabItem>
<TabItem value='select'>

If we would like to categorize them using Wildcards, we would have to create a separate WHEN for each ID.

```sql {5-14} title="This approach would require 36 WHEN/THEN lines to cover the use case"
SELECT
    SubscriberKey,
    EmailAddress,
    CASE
        WHEN RecommendedProducts LIKE '1' THEN 'Premium'
        WHEN RecommendedProducts LIKE '1,%' THEN 'Premium'
        WHEN RecommendedProducts LIKE '%,1,%' THEN 'Premium'
        WHEN RecommendedProducts LIKE '1,%' THEN 'Premium'
        WHEN RecommendedProducts LIKE '2' THEN 'Premium'
        WHEN RecommendedProducts LIKE '2,%' THEN 'Premium'
        ...
        WHEN RecommendedProducts LIKE '5' THEN 'Standard'
        WHEN RecommendedProducts LIKE '5,%' THEN 'Standard'
        ...
        ELSE 'No Subscription'
    END AS RecommendedSubscriptionType
FROM EcommerceUpsellDE
```

With group, we can optimize it. A lot.

```sql {5-12} title="Same outcome with just 8 WHEN/THEN lines"
SELECT
    SubscriberKey,
    EmailAddress,
    CASE
        WHEN RecommendedProducts LIKE '[1234]' THEN 'Premium'
        WHEN RecommendedProducts LIKE '[1234],%' THEN 'Premium'
        WHEN RecommendedProducts LIKE '%,[1234],%' THEN 'Premium'
        WHEN RecommendedProducts LIKE '[1234],%' THEN 'Premium'
        WHEN RecommendedProducts LIKE '[56789]' THEN 'Standard'
        WHEN RecommendedProducts LIKE '[56789],%' THEN 'Standard'
        WHEN RecommendedProducts LIKE '%,[56789],%' THEN 'Standard'
        WHEN RecommendedProducts LIKE '[56789],%' THEN 'Standard'
        ELSE 'No Subscription'
    END AS RecommendedSubscriptionType
FROM EcommerceUpsellDE
```

</TabItem>
</Tabs>

Thanks to group operator, instead of covering every single case, we can just provide them all within the `[]`. Short, clean and readable. And it can get even better.

:::note You Should Know

Group operator has also another use. It allows you to search for the `%` or `_` symbols with `LIKE`. As those two symbols are wildcards, you must TODO

:::

### - Operator

We can simplify more with the use of range operator `-`. Instead of writing each possible character within our group `[]` (it gets really awful when we are looking for any letter regardless of its case), we can ask for a range:

<Tabs
    defaultValue='where'
    values={[
        {label: 'WHERE', value: 'where'},
        {label: 'SELECT', value: 'select'},
    ]}
>
<TabItem value='where'>

```sql {6-9} title="Now with range operator"
SELECT
    SubscriberKey,
    EmailAddress,
    RecommendedProducts
FROM EcommerceUpsellDE
WHERE RecommendedProducts LIKE '[1-4]'
    OR RecommendedProducts LIKE '[1-4],%'
    OR RecommendedProducts LIKE '%,[1-4],%'
    OR RecommendedProducts LIKE '%,[1-4]'
```

</TabItem>
<TabItem value='select'>

```sql {5-12} title="Now with range operator"
SELECT
    SubscriberKey,
    EmailAddress,
    CASE
        WHEN RecommendedProducts LIKE '[1-4]' THEN 'Premium'
        WHEN RecommendedProducts LIKE '[1-4],%' THEN 'Premium'
        WHEN RecommendedProducts LIKE '%,[1-4],%' THEN 'Premium'
        WHEN RecommendedProducts LIKE '[1-4],%' THEN 'Premium'
        WHEN RecommendedProducts LIKE '[5-9]' THEN 'Standard'
        WHEN RecommendedProducts LIKE '[5-9],%' THEN 'Standard'
        WHEN RecommendedProducts LIKE '%,[5-9],%' THEN 'Standard'
        WHEN RecommendedProducts LIKE '[5-9],%' THEN 'Standard'
        ELSE 'No Subscription'
    END AS RecommendedSubscriptionType
FROM EcommerceUpsellDE
```

</TabItem>
</Tabs>

As you can see, all we need to do, it to put range operator `-` between first and last value that we want to catch. For alphabetical searches where we want both lowercase and uppercase letters, you will need to write it like this: `LIKE '[a-zA-Z]'`.

:::note You Should Know

You can mix and match groups, ranges and wildcards.

```sql title="Simplified Job Title categorization"
SELECT
    SubscriberKey
    CASE
        WHEN FreeTextJobTitle LIKE '[Cc]_[Oo]' THEN 'C-Suite'
        WHEN FreeTextJobTitle LIKE '%[Mm]anager%' THEN 'Management'
        WHEN FreeTextJobTitle LIKE '%[Ss]pecialist%' THEN 'Specialists'
    END AS CorporateJobTitleGroup
FROM _Subscriber

:::

### ^ Operator

There is one more operator that is sometimes useful - the exclusion operator `^`. By adding it to the beginning of your group, you are telling the SQL to look for any character not like the ones within the group. For example, `LIKE '[^0-9]'` will look for any character that is not a digit. It is, however, much more useful in the [`WHERE` Statement](sfmc-sql-where#like-operator).

Remember, you can use multiple Group operators within a single `LIKE`.

:::note You Should Know

Group wildcard (`[]`) is also useful as a way to escape character in the `LIKE` statement. For example, you might want to look for all values including a percent sign (`%`).

Writing `LIKE '10%'` is not good idea, as it would return to you all values starting with `10` - as the percent sign is a wildcard meaning zero, one or more characters. You can, however, obtain exactly what you want by writing:

```sql {4-5} title="If the client has discount between 1 and 9%, let's bump it up to either 5% or 10%. If he or she has higher - leave it as it is. If no discount is available, make it 2%"
SELECT
    ContactKey,
    CASE
        WHEN Discount LIKE '[5-9][%]' THEN '10%'
        WHEN Discount LIKE '[0-4][%]' THEN '5%'
        WHEN Discount IS NOT NULL THEN Discount
        ELSE '2%'
    END AS NewDiscount
```

By wrapping the percent sign with the grouping sign `[]` we are telling SQL to look for exactly the percent sign. Thanks to it `'[1-4][%]'` search will look for `1%`, `2%`, `3%` or `4%` values only.

If you want to search for a hyphen '-' within a grouping operator using a range, just add it in the very beginning. `LIKE '[-0-9]` will look for either `-` or any digit.

:::

## NOT LIKE

You can add `NOT` statement before `LIKE` to search for not matching records.

```sql {4} title="Same query as in the beggining of our CASE journey, but flipped"
SELECT
    ContactKey,
    CASE
        WHEN EmailAddress NOT LIKE '%@mateuszdabrowski.pl' THEN 'External'
        ELSE 'Internal'
    END AS ContactType
```