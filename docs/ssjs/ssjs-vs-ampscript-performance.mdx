---
id: ssjs-vs-ampscript-performance
title: SSJS vs AMPScript Performance
sidebar_label: Performance
description: Should I use AMPScript or SSJS? Check the performance comparisions for various use cases.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { LeadText } from '../../src/components/LeadText.js';

<LeadText content='Should I use AMPScript or SSJS? Check the performance comparisions for various use cases.' />

In Salesforce Marketing Cloud world there is a lot of knowledge shared on blogs, social networks and Stack Exchange. Frequently you will see some strong opinions on which approach is best.

I decided to check some of those assumptions empirically. Some test results are obvious, some might surprise you (just as they surprised me).

The article is split into two sections:

1. [Conclusions](#conclusions) are the TLDR of my tests. If you just want to check which approach might be best for your use case - go there.
2. [Performance Test Cases](#performance-test-cases) are the nerdy part, where I describe the exact code used for each case and more detailed outcomes that might give you better basis for a decision what to use.

:::note You Should Know

This article will be in constant Work In Progress state, as I plan to periodically add new test cases and update conculsions.

Should you have any interesting idea for a test case - let me know!

:::

## Conclusions

Execution time differences are very small - at a few or dozen milisecond here or there, too small to have an impact for most Cloud Page backends, Automation Studio Script Activities or Apps for internal use created within Marketing Cloud. For those use cases I definitely prefer SSJS.

But for scripting in communication assets (Emails, SMS, Pushes, etc) that will be send to huge volumes or when the previously mentioned use cases apply the script to a big data extensions, it might have significant impact and help you optimize your Marketing Cloud greatly.

1. For scripting in time-critical assets (Emails, SMS, Pushes) go with AMPScript. It is much more optimized for the most popular use cases in this space.
2. For scripting in other assets (Landing Pages, Automation Studio) it depends on the use case. As a rule of thumb, AMPScript might be a bit more optimized, but lacks flexibility and power (arrays, objects, try/catch, etc.).
3. When splitting your SSJS code block, try not to do it within a long loop ([Code Block Breaking](#code-block-breaking)).
4. However, if AMPScript have a ready-to-use function that is not available in SSJS, it might be worth to inject AMPScript into your SSJS. The execution time impact of code splitting might be much smaller then that of the complex code necessary to duplicate this function ([ProperCase](#propercase)). For functions available in both languages, in most cases it's better to stay with the one already used ([LowerCase & UpperCase](#lowercase--uppercase)).

## Methodology

The methodology is very limited by the nature of SSJS and AMPScript. I'm using a Cloud Page and use `new Date().getTime();` to capture beginning and end of the execution. Within this scope, I run a loop with the code I want to test. Finally, I divide the time needed for whole execution by the number of loop iterations to get an average run time.

This approach means that the milisecond values I provide are no way the exact times you can use to calculate the speed at scale. But in the same time should be standardized enough to allow for meaningful comparision between various scenarios. The exact times  also change a bit when the test is run multiple times, as the strain on Marketing Cloud servers at the very moment of execution also has an impact. Focus less on exact milisecond count and more on relations between values.

In the below test case description you can find additional details on the methodology, like input used for test, number of iterations used for loops or exact code that was tested.

:::note You Should Know

For testing the execution speed of AMPScript block solutions, I'm using the SSJS to start and stop the count. I compared it with calculation using AMPScript `FormatDate(Now(), 'iso')` and there was no meaningful difference between the two.

:::

## Performance Test Cases

### Code Block Breaking

First thing I wanted to test was the cost of breaking out of code block between SSJS and AMPScript.

Understanding the execution time impact of that context switch is not only necessary to make valid conclusions from future tests, but also can help decide on the best approach when coding a personalisation.

<Tabs
    defaultValue='ssjs'
    values={[
        {label: 'SSJS', value: 'ssjs'},
        {label: 'SSJS + HTML', value: 'html'},
        {label: 'SSJS + AMPScript', value: 'ampinssjs'},
        {label: 'AMPScript', value: 'ampscript'},
        {label: 'AMPScript x2', value: 'ampscript2'},
    ]}
>
<TabItem value='ssjs'>

In this scenario, there is no context switch. I timed pure SSJS loop to have a base for analysis.

```
for (var i = 0; i < 10000; i++) {
    var a;
}
```

</TabItem>
<TabItem value='html'>

Next scenario is simple breaking out of SSJS within a loop.

```
for (var i = 0; i < 10000; i++) {
    var b;
    </script>

    <script runat="server">
}
```

</TabItem>
<TabItem value='ampinssjs'>

Next level is making an AMPScript block within the break.

```
for (var i = 0; i < 10000; i++) {
    </script>
    %%[
        VAR @c
    ]%%
    <script runat="server">
}
```

</TabItem>
<TabItem value='ampscript'>

Then I put the for loop in the AMPScript context. This makes the SSJS breaking impact count only once per 10 000 executions, making it irrelevant for the final average.

```
</script>
%%[
    FOR @current = 1 TO 10000 DO
        VAR @d
    NEXT @current
]%%
<script runat="server">

```

</TabItem>
<TabItem value='ampscript2'>

For final scenario I decided to break out of AMPScript context within an AMPScript loop, as this is popular way for creating dynamic content in Marketing Cloud.

```
</script>
    %%[
    FOR @current = 1 TO @Counter DO
        VAR @d
        ]%%

        %%[
    NEXT @current
    ]%%
<script runat="server">
```

</TabItem>
</Tabs>

#### Outcomes

SSJS | SSJS + HTML | SSJS + AMPScript | AMPScript | AMPScript x2
-- | -- | -- | -- | --
0.0016 | 0.1453 | 0.1422 | 0.0015 | 0.0016

#### Sum Up

1. Breaking out of SSJS code block is impacting execution time. It is not a problem for AMPScript.
2. Be very cautious of breaking out of SSJS code block within [loop](./ssjs-loops.mdx), as this might have enormous impact on the execution time.

### ProperCase

What should you use, when you want to change a string to Proper Case? As there is no single function in SSJS for that, I compared two pure SSJS approaches (`split`/`join` & `replace` with RegEx) with [AMPScript in SSJS](./ssjs-snippet-ampscript-in-ssjs.mdx) and (nearly) pure AMPScript.

The test was performed using ten different strings varying in number of words and capitalization:
```js
var sentences = [
    'one',                                      // 1
    'one Two',                                  // 2
    'one Two THREE',                            // 3
    'one Two THREE fOUR',                       // 4
    'one Two THREE fOUR FiVe',                  // 5
    'one Two THREE fOUR FiVe siX',              // 6
    'one Two THREE fOUR FiVe siX &',            // 7
    'one Two THREE fOUR FiVe siX & 8',          // 8
    'one Two THREE fOUR FiVe siX & 8 nine',     // 9
    'one Two THREE fOUR FiVe siX & 8 nine-ten'  // 10
];
```

All approaches output final sentence as: `One Two Three Four Five Six & 8 Nine-ten`

<Tabs
    defaultValue='split'
    values={[
        {label: 'SSJS Split', value: 'split'},
        {label: 'SSJS Replace', value: 'replace'},
        {label: 'AMPScript in SSJS', value: 'ampinssjs'},
        {label: 'AMPScript', value: 'ampscript'},
    ]}
>
<TabItem value='split'>

```
function toTitleCase(string) {
    var sentence = string.toLowerCase().split(" ");
    for (var i = 0; i < sentence.length; i++) {
        sentence[i] = sentence[i][0].toUpperCase() + sentence[i].slice(1);
    }
    sentence = sentence.join(" ");
    return sentence;
}

title = toTitleCase(testedString);
```

</TabItem>
<TabItem value='replace'>

```
title = testedString.replace(
    /[a-zA-Z]\S*/g, function(string) {
        return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase()
    }
);
```

</TabItem>
<TabItem value='ampinssjs'>

```
title = ampScript("SET @Response = ProperCase('" + testedString + "')");
```

</TabItem>
<TabItem value='ampscript'>

```
%%[
SET @Response = ProperCase(@Sentence)
]%%
```

</TabItem>
</Tabs>

#### Outcomes

Sentence | SSJS Split | SSJS Replace | AMPScript in SSJS | AMPScript
-- | -- | -- | -- | --
1 | 0.0968 | 0.0782 | 0.3686 | 0.0032
2 | 0.1376 | 0.1186 | 0.3688 | 0.0032
3 | 0.175 | 0.1594 | 0.3874 | 0.0032
4 | 0.2218 | 0.2032 | 0.375 | 0.0062
5 | 0.2562 | 0.247 | 0.3686 | 0.0064
6 | 0.2968 | 0.2812 | 0.372 | 0.0062
7 | 0.3344 | 0.2844 | 0.375 | 0.003
8 | 0.372 | 0.2874 | 0.372 | 0.003
9 | 0.4126 | 0.3312 | 0.3718 | 0.0064
10 | 0.4124 | 0.342 | 0.375 | 0.0064

#### Sum Up:

1. Pure AMPScript execution time for ProperCase scenario murders SSJS.
2. When working with arrays or regex replace, SSJS execution time extends with each additional word. However, AMPScript execution time is constant.
3. Despite [AMPScript in SSJS](./ssjs-snippet-ampscript-in-ssjs.mdx) doing levels-of-magnitude worse then pure AMPScript, it will be a better choice then pure SSJS for long sentences (10+ words). As mentioned in the [article](./ssjs-snippet-ampscript-in-ssjs.mdx) - use that approach only when there is no other option.
4. SSJS Replace might be the option to choose even despite performance, if you want more flexibility (for example, changing that `Nine-ten` to `Nine-Ten`).

### LowerCase & UpperCase

The test was performed using ten different strings varying in number of words and capitalization:

```js
var sentences = [
    'one',                                      // 1
    'one Two',                                  // 2
    'one Two THREE',                            // 3
    'one Two THREE fOUR',                       // 4
    'one Two THREE fOUR FiVe',                  // 5
    'one Two THREE fOUR FiVe siX',              // 6
    'one Two THREE fOUR FiVe siX &',            // 7
    'one Two THREE fOUR FiVe siX & 8',          // 8
    'one Two THREE fOUR FiVe siX & 8 nine',     // 9
    'one Two THREE fOUR FiVe siX & 8 nine-ten'  // 10
];
```

All approaches output final sentence as: `one two three four five six & 8 nine-ten`

<Tabs
    defaultValue='method'
    values={[
        {label: 'SSJS Method', value: 'method'},
        {label: 'SSJS Function', value: 'function'},
        {label: 'AMPScript in SSJS', value: 'ampinssjs'},
        {label: 'AMPScript', value: 'ampscript'},
    ]}
>
<TabItem value='method'>

```
title = testedString.toLowerCase();
```

</TabItem>
<TabItem value='function'>

It doesn't make sense in this case, but gives idea on the impact of using function vs method approach.

```
function toLowerCase(string) {
    var sentence = string.toLowerCase()
    return sentence;
}
title = toLowerCase(sentences[a]);
```

</TabItem>
<TabItem value='ampinssjs'>

```
title = ampScript("SET @Response = LowerCase('" + testedString + "')");
```

</TabItem>
<TabItem value='ampscript'>

```
%%[
SET @Response = LowerCase(@Sentence)
]%%
```

This solution was timed from SSJS Context and used `Variable.SetValue` for passing the testedString to AMPScript Context.

This approach has impact on the exact number of miliseconds, but does not change the final conclusion.

</TabItem>
</Tabs>

#### Outcomes

Sentence | SSJS Method | SSJS Function | AMPScript in SSJS | AMPScript
-- | -- | -- | -- | --
1 | 0.014 | 0.0203 | 0.3625 | 0.0032
2 | 0.0125 | 0.0187 | 0.3625 | 0.0031
3 | 0.0125 | 0.0188 | 0.3625 | 0.0031
4 | 0.0125 | 0.0188 | 0.3687 | 0.0016
5 | 0.0125 | 0.0187 | 0.3641 | 0.0015
6 | 0.0125 | 0.0188 | 0.3641 | 0.0031
7 | 0.0125 | 0.0187 | 0.3625 | 0.0032
8 | 0.0125 | 0.0187 | 0.3672 | 0.0031
9 | 0.0125 | 0.0204 | 0.3593 | 0.0032
10 | 0.014 | 0.0203 | 0.3625 | 0.0016

#### Sum up