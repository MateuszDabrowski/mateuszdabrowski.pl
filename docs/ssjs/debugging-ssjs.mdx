---
id: debugging-ssjs
title: Debugging & Error Handling
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { LeadText } from '../../src/components/LeadText.js';

<LeadText content='To catch, or not to catch, that is debugging.' />

When you start working with programmatic languages in Salesforce Marketing Cloud, you will quickly become close friends with Error 500 page. And if you beat it and go a bit deeper into the code and official documentation, you will also fall in love with unexpected errors in function and API responses. How to survive those?

----

## SSJS Testing Ground

Let's talk where to write the SSJS. The language is useful in many places within the Marketing Cloud ecosystem, among else:

- Cloud Pages (Web Studio)
- Code Resources (Web Studio)
- Content Blocks (Content Builder)
- Emails and other communication (Email Studio / Content Builder)
- Script Activities (Automation Studio)

In all of the above cases, you might write more complex logic that will be error-prone and in need of debugging. However, only a few of those are good to test your code, as only some of them will allow you to leverage the methods mentioned later in the article.

### Cloud Page

The most popular recommendation is Cloud Page - write or paste the SSJS code there, publish and check whether it is working correctly. It is a great way, as it allows you to easily leverage SSJS for backend and HTML/CSS/JavaScript for frontend.

It has, however, two flaws that, in some scenarios, might guide you to a different solution.

1. **Cost**. Each view of the Cloud Page cost one Super Message. During debugging, you might hit quite a lot of those. And those tests across your team and over time stack up.
2. **Speed and context**. Each time you want to republish updated Cloud Page you have to go through the Preview windows that load the whole code in POST method context, confirm it and go to the page via URL to see GET method context.

### JSON Code Resource

When I want to go around those issues, I go with JSON Code Resource (also available in Web Studio). It generates a link you can use to check whether everything works just as a Cloud Page. However, page views are free. There is also no preview allowing for faster save-reload.

The cons? You won't be able to use any frontend (neither HTML nor JavaScript), which might be a deal-breaker in some scripts that you want to test.

### So where?

If you need | Cloud Page | JSON Code Resource
-- | -- | --
SSJS | ‚úÖ | ‚úÖ
HTML/CSS/JS | ‚úÖ | ‚ùå
No Cost |  ‚ùå | ‚úÖ
Quick Save | ‚ùå | ‚úÖ

:::note Email Studio

Some also use Email Studio for testing various scripts, but I recommend against it. It doesn't support SSJS Core Library. Even if you don't need it for your script, it is very useful for debugging.

:::

----

## 500 - Internal Server Error

TODO: Validate and inform why try/catch won't solve 500

The first type of error you might encounter is the dreaded 500 Error that you see right after *trying* to run your code. Reason? The code backend (SSJS/AMPScript) is invalid. There might be a few reasons for this. The most popular are:

1. Typo in SSJS Function Name
2. Unclosed or wrongly closed Bracket
3. Use of JavaScript feature that is not available in SSJS (and there is quite a lot of those...)
4. Lack of declaration (in most cases either missing `Platform.Load("Core","1");` or `var soap = new Script.Util.WSProxy();` while using related functions)

How to deal with those issues? Apart from just reading through your code line by line, there are two faster solutions.

### Divide and Conquer

The first one can be done directly in the Marketing Cloud but is a bit of a brute-force approach. You comment out half of your code with `/* here goes the code */` and check again. If it works, you have half of the SSJS validated (from the 500 error perspective). If not, you split the remaining code in half and comment it out. This way, you can quite quickly find the few lines that are leading to the issue and focus only on them.

### SSJS Linting

For many of the reasons leading to 500 error, there is an even faster solution, but with some pre-requisites:

1. You need to have [Visual Studio Code](https://code.visualstudio.com/ "Visual Studio Code Website") with [ESLint extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint "ESLint in Visual Studio Code Marketplace") installed.
2. You need to have [NodeJS](https://nodejs.org/en/ "NodeJS Website") installed.
3. You need to have a folder where you will store your SSJS code in files with `.ssjs` file extension.
4. You need to install the excellent [ESLing configuration for SSJS](https://github.com/JoernBerkefeld/eslint-config-ssjs "Joern Berkefeld Github Project with Config") made by [Joern Berkefeld](https://www.linkedin.com/in/joernberkefeld/ "Joern Berkefeld LinkedIn"). To do this, run in terminal `npx i -D eslint eslint-config-ssjs` for the SSJS folder.

Voila, automatic SSJS code validation (again, only from the perspective of 500 error - but it is still worth it).

TODO: Validate whether Script Automation might be simplified work around

----

## Write the Error down

Once we get past the 500 error, it is time to check what else might be wrong. The easiest way is to use the Write function. It shows whatever you pass in it to the frontend view. This is why, it is good to leverage choose right [Testing Ground](#ssjs-testing-ground). It is especially useful, SSJS does not support console.log due to it server-side nature (a little trick to make it work will be soon).

To use this function, within `<script runat=server>` and `</script>` add `Write('This will be visible on the website')`.

Of course, in real life, you will probably want to use it for variables:

```html {4}
<script runat=server>
    Platform.Load('Core','1');
    var response = HTTP.Get('http://www.example.com');
    Write('Response from example.com: ' + response + '<br><br>');
</script>
```

As you can see in the code snippet above I have more than just `response` in my `Write`. The element before is description and will help you understand what is printed (especially if you use multiple Writes in yoru code). The one after - `<br><br>` - will separete it from the rest of the website content (however, it won't work in JSON Code Resource, as it is HTML). I highly recommend this approach.

:::note Few things to remember

1. `Write` is Core Library function, so you need to load it in your script.
2. As all Core Library functions, it will not function in Emails or SMS.
3. If the variable you want to write is an object, you need to parse it to string using `Stringify(response)`.

:::

### Debugging Variable

Whenever you are creating a script that will be used for longer time, it is worth to keep your debugging `Write` functions. Data sources you use change. Marketing Cloud itself too. And sometimes those things might break your code.

Of course, keeping the `Writes` as above is a no-go. You don't won't your customers to see those. But there is a neat little trick to eat the cake and have it too:

```html {3,7}
<script runat=server>
    Platform.Load('Core','1');
    var debugging = true;

    var response = HTTP.Get('http://www.example.com');

    if (debugging) {
        Write('Response from example.com: ' + response + '<br><br>');
    }
</script>
```

I changed here two things:
1. There is `var debugging = true` near the top. This is our variable that will allow us to control whether `Write` writes. When debugging, keep it on `true`. When you publish it for production - change the value to `false`.
2. The above value will be used in second new element - the `if` statement. It checks what is the value of `debugging` variable and runs `Write` only if it is `true`.

### Console Logging

I mentioned before that SSJS does not support `console.log` as it is executing on server. There is however a workaround, that might bring the SSJS values to your console. SSJS personalization strings passed to your JavaScript:

```js
console.log('Response from example.com' + '<ctrl:var name=response />')
```

:::note Passing Objects from SSJS to JS

If the variable you want to pass to JavaScript was a SSJS Object, you will need to create a parsed variable to make it work:
1. In SSJS create for example `var parsedResponse = Stringify(response)`
2. In JS change the personalization to `console.log(<ctrl:var name=parsedResponse />)` (different name value and lack of quotes around personalization)

:::

----

## Try to Catch the Error

Using `Write` is great and simple solution, but it will work only if the code will work. And sometimes it won't. For those cases, add a `try/catch` block. Check also the Response tab below to compare difference between writing `response` variable and writing catched error.

<Tabs
    defaultValue='request'
    values={[
        {label: 'Request', value: 'request'},
        {label: 'Response', value: 'response'},
    ]}
>
<TabItem value='request'>

```html {5,7} title="GET request to invalid URL within Try/Catch block"
<script runat=server>
    Platform.Load('Core','1');
    var debugging = true;

    try {
        var response = HTTP.Get('http://www.example.c');
    } catch (error) {
        if (debugging) {
            Write('Error caught: ' + Stringify(error) + '<br><br>')
        }
    }

    if (debugging) {
        Write('Response from example.com: ' + response + '<br><br>');
    }
</script>
```

</TabItem>
<TabItem value='response'>

```json title="Outcome visible on the Website"
Error caught: {"message":"An error occurred when attempting to evaluate a HTTPGet function call.  See inner exception for details.\r\n  ClientID: 518000476\r\n  JobID: 0\r\n  ListID: 0\r\n  BatchID: 0\r\n  SubscriberID: 0\r\n  URL: http://www.example.c\r\n","description":"ExactTarget.OMM.FunctionExecutionException: An error occurred when attempting to evaluate a HTTPGet function call.  See inner exception for details.\r\n  ClientID: 518000476\r\n  JobID: 0\r\n  ListID: 0\r\n  BatchID: 0\r\n  SubscriberID: 0\r\n  URL: http://www.example.c\r\n  Error Code: OMM_FUNC_EXEC_ERROR\r\n - from Jint --> \r\n\r\n --- inner exception 1---\r\n\r\nExactTarget.OMM.OMMException: An exception occurred when attempting to retrieve content by a HttpGet call.  URL: http://www.example.c\r\n  Error Code: HTTP_WB_RTV\r\n - from OMMCommon --> \r\n\r\n --- inner exception 2---\r\n\r\nSystem.Net.WebException: The remote name could not be resolved: 'www.example.c' - from System\r\n\r\n\r\n\r\n\r\n\r\n"}

Response from example.com: undefined
```

As you can see, this response is quite long. In most cases the most important information is in the last sentence. In this example we learn that `System.Net.WebException: The remote name could not be resolved: 'www.example.c' - from System`.

You can also see why Try/Catch block is so valuable, as our `Write` printed `undefined`, which isn't very helpful. This is due to the fact, that because of the invalid URL, the response to our GET was not filled.

</TabItem>
</Tabs>


During debugging it is especially useful for SSJS Functions that are calling external data. Marketing Cloud Data Extensions, Salesforce Core Objects or even element from outside Salesforce environment. It also might help when you are doing operations on responses from such sources. For example trying to get value from nested response object.

:::note You should know

Try/Catch block in SSJS has its own scope, unlike in modern JavaScript. This means that any **variables declared within the block won't be accessible from outside**. Neither in the other parts of SSJS nor in personalization strings.

There is a way to overcome this limitation. Declare the variables you want to use globally before the `try` and just modify their values within the block:

```html {4,6}
<script runat=server>
    Platform.Load('Core','1');

    var response;
    try {
        response = HTTP.Get('http://www.example.com');
    } catch (error) {
        // Error handling logic
    }
</script>
```

:::

----

## Error Logging

One you debug your code using the above methods, it is still good idea to program defensively and leverage the Try/Catch block even on production code. It will allow you to handle the errors for the customers (for example, redirect them to a Error Landing Page) and to log the errors to a data extension (it will provide you a history of problems along with description of what happened). You can even try to build something more sophisticated and for example leverage REST API of your JIRA to automatically create a bug ticket.

### Logging to Data Extension

The easiest way to log your errors is to leverage built-in into Marketing Cloud Data Extensions.

My recommendation is to create one Data Extension that will capture the errors from whole instance. It will make it much easier and faster to quickly check whether there are any new issues to check.

TODO: Add Data Extension Settings Details

### Global Error Catching

Instead of writing Try/Catch blocks for every potentially risky function, you might create just one block that will capture whole code. You can even use it to catch errors in your AMPScript, as described by [Zuzanna Jarczy≈Ñska](https://sfmarketing.cloud/2019/08/09/debugging-ampscript/ "Blog post on AMPScript Debugging on sfmarketing.cloud").

This approach might make your code shorter and easier to read, but will limit your control over specific handling for various scenarios.

:::note You Should Know

If you use any kind of redirect within your `try` block, it will be considered as error caught. If you need to use redirect, don't use global Try/Catch and instead leverage it only in potentially problematic code.

:::

----

## Error Handler Function

Once you start implementing various solutions mentioned in this article, it might get quite repetitive to add the same lines for conditional `Write`, log to Data Extension, etc.

You can solve it by createing an Error Handler function once and then just call it whenever it is needed:

```html {5,16}
<script runat=server>
    Platform.Load('Core','1');
    var debugging = true;

    function handleError(error) {
        if (debugging) {
            Write(Stringify(error))
        } else {
            Platform.Function.InsertData('Data_Extension_Name', ['id', 'errorSource', 'errorMessage', 'errorDescription'], [GUID(), 'Name of the place where the script runs', Stringify(error.message), Stringify(error.description)]);
        }
    }

    try {
        var response = HTTP.Get('http://www.example.c');
    } catch (error) {
        handleError(error);
    }
</script>
```

Whenever Try/Catch block finds an error, the above snippet will check the value of debugging variable. If it is set to `true`, it will just Write the error to the page to make it easier to quickly debug. If it is set to `false`, it will add the error to the Data Extension instead.

We are leveraging here the fact that most Marketing Cloud Errors are built as an object with two keys: `message` and `description`. Putting those elements into separate columns of the Data Extension make it easier to read the log.

Using Error Handler Function is useful especially when you are triggering it multiple times in various Try/Catch blocks or when you have elaborate logic for handling (for example API calls to external systems for bug tracking).

:::note You Should Know

You can also create your custom error, by passing your own object to the `handleErrror` function:

```js {4}
try {
    // Risky code
} catch (error) {
    handleError({message: 'Custom Error Message', description: 'Custom Error Description'});
}
```

:::

----

## Sum Up

If you have any problems with your SSJS code:
1. Test it in Cloud Page or JSON Code Resource [üîó](#ssjs-testing-ground)
2. Overcome 500 Error with linting or divide & conquer methodology [üîó](#500---internal-server-error)
3. Use `Write` function to understand what happens with your variables during execution [üîó](#write-the-error-down)
4. Use Try/Catch block to understand better what is the reason for errors you encounter [üîó](#try-to-catch-the-error)
5. Save errors from your production code to easily track and solve the problems [üîó](#error-logging)
6. Simplify the approach with custom Error Handler Function [üîó](#error-handler-function)