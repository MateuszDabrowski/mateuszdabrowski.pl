---
id: zen-of-sfmc
title: Zen of SFMC
description: Salesforce Marketing Cloud implementation, development and operations Best Practices. In brief and in detail.
image: img/og/og-image-solve-with-cloud--page-apps.png
tags: [Marketing Cloud, Best Practice]
toc_max_heading_level: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { LeadText } from '../src/components/LeadText.js';

<LeadText content="Salesforce Marketing Cloud implementation, development and operations Best Practices. In brief and in detail." />

I'm a huge fan of Tim Petter's [PEP20 - Zen of Python](https://www.python.org/dev/peps/pep-0020/). In 19 short lines, he described his recommendations for writing good Python code. The outcome transcended the specific language and I see it as a very universal guide on software engineering.

In this article I share my Salesforce Marting Cloud adaptation and interpretation of this pearl. Expect some modifications to the original text (minimal, as most of the recommendations are perfectly valid for our Marketing Automation world), followed by my comments on how particular lines can be beneficial for SFMC practice.

## Zen of SFMC

```txt
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Naming conventions counts twice.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
Even when certain, test.
Now is better than never.
Although never is often better than right now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Documentation is one honking great idea - let's do more of it!
```

## Thoughts on Zen

Remember that those recommendations are just that - recommendations. Not strict rules, but rather a set of general - sometimes contradictory - principles, that might help you in your day-to-day work with Salesforce Marketing Cloud.

---

### Beautiful is better than ugly

Beauty might not immediately come to the mind in the context of software development and implementation. Neither might it be in the focus in the world of short deadlines and evergrowing KPIs. However, one should not forget about beauty when deploying Marketing Cloud solutions.

It not only makes working on the tool more motivating and pleasant, but also supports a lot of other recommendations listed here - with readability in the first place. Below you can see examples of how the beauty principle can be implemented into Salesforce Marketing Cloud world.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

When you are writing code in Salesforce Marketing Cloud - be it AMPScript, SSJS, SQL, or other - you have a lot of flexibility when it comes to the structure and style. Random indentation, lack of new lines, cryptic variables? Everything is possible and might work.

But you should strive to write code that not only works. Apply beauty-focused mindset and while writing might take a bit longer, the outcome will be more readable, easier to debug and understandable to others.

```sql title="Both queries work - which one would you rather read?"
/* Beauty */
SELECT
      wel.SubscriberKey     AS SubscriberKey
    , wel.EmailAddress      AS EmailAddress
    , o.EventDate           AS OpenDate
FROM WelcomeCampaignSegment AS wel
    INNER JOIN _Open        AS o
        ON o.SubscriberKey = wel.SubscriberKey

/* and the Beast */
select a.subscriberkey, a.emailaddress, b.eventdate
from welcomecampaignsegment a join _open b on a.subscriberkey = b.subscriberkey

```

Check my Style Guides for [AMPScript](../ampscript/ampscript-style-guide/), [SSJS](../ssjs/ssjs-style-guide/), [SQL](../sql/sfmc-sql-style-guide/) to see more specific examples on how to make your code beautiful.

</TabItem>
<TabItem value='ui'>

The choice betweem beauty and ugly is not limited to writing the code. The same is true for working with Salesforce Marketing Cloud no-code tools.

Creating a Email Template using Blocks in Content Builder? Sure, you can just drag and drop the empty blocks in proper order and call it a day. But you can also put a bit more work and add sample content with predefined styles to each block, provide palceholder images with visible dimensions and save such elements as separate blocks ready for reuse.

Both approaches deliver the Email Template, but the second one does it in a more beautiful way improving the usefulness and value of the final solution.

</TabItem>
</Tabs>

---

### Explicit is better than implicit

Salesforce Marketing Cloud enables you to decide, whether you want to create things in an implicit or explicit way. Implicit is faster and easier. Explicit is sturdier and better.

As the SFMC is long term commitmentused by many people, it's always worth to spend a bit more effort and go for explicit whenever possible. It will save you and your organisation a lot of time in the long run, so consider it an investment.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

There are a lot of tricks we can use when coding for Salesforce Marketing Cloud - implicit data type conversions, undocumented endpoints and function behaviours or just language specific synctatic sugar. As helpful as they are, they obscure readability, introduce error risk to the code and won't be known by everyone.

This is why, unless such tricks are necessary, it's good idea to go for the explicit, clear and obvious version. Even if it is slightly longer or not as sexy.

Of course, not always it will be possible - some things are only possible by coding on the edge of the documentation. Not all is lost, however, as you can make such cases more explicit with good comments. And don't limit those for just the tricky parts. Describing even the cleanest functions and scripts will help you and your team work more effectively.

```js title="'Code tells you how. Comments tell you why.' - Jeff Atwood"
/**
 * @function debugValue
 * @description Outputs provided description and SSJS value to front-end in a type-safe & consistent way
 * @param {string} description - Describes meaning of the second parameter in the output
 * @param {*} value - The value that needs to be debugged
 */
function debugValue(description, value) {
    Write(description + ': ' + (typeof value == 'object' ? Stringify(value) : value) + '<br><br>');
};
```

Read more on using comments in [SSJS](../ssjs/ssjs-style-guide/#comments) and [AMPScript](../ampscript/ampscript-style-guide/#comments).

:::note You Should Know

Explicit approach can (and should) be taken to the next level with smart use of asset Keys. They are frequently used in code - especially the Data Extension and Content Block keys. While the default pseudo-random ID does the work, I recommend going for the custom explicit Keys.

If you keep Data Extension Name and Key in sync (it might not be possible with longer names due to Key length limit) you won't have to worry about whether the Data Extension lookup is using the key or name.

But even bigger value to this approach is with Content Blocks. It's popular to use those Blocks for AMPScript snippets shared across multiple emails or brand-wide dynamic footers. Frequently they are added to the Email Templates with the help of AMPScript `ContentBlockByID` function. However, as an asset collection grows, it will be harder to remember which Content Block has been imported that way (IDs aren't helpful with that).

Explicit Content Block Key and `ContentBlockByKey` function can help with that:

```js title="Which one would you rather see in the email template?"
%%=ContentBlockByID("123456")=%%
// vs
%%=ContentBlockByKey("SharedFooterEMEA")=%%
```

:::

</TabItem>
<TabItem value='ui'>

Being explicit is not limited to the code. When working with the SFMC no-code features, you will also have a lot of places to improve your solution with a bit of added information.

A lot of assets offer one or more places to add descriptions. Data Extensions, Installed Packages, Automations - or even specific steps grouping Activities. Neither of those places _require_ a description, but each and single one will benefit from explicitly stating it's purpose and business/technical context.

There are also places where Salesforce Marketing Cloud let's you add smaller pieces of information. Not full descriptions, but rather optional micro data points that explain the purpose. Path names in Journey Builder Decision Splits. Additional Email Attribute Names in Content Builder. Collection and Cloud Page names in Web Studio. Whenever possible - spend that extra time needed to come up with explicit value.

</TabItem>
</Tabs>

---

### Simple is better than complex

Marketing Cloud is a complex tool within a complex Salesforce ecosystem focused on solving complex business needs. But how you operate and develop SFMC should be as straightforward as possible. It will make your solution robust, agile and easily understandable.

#### KISS

This recommendation is also known in the software development community under a popular acronym: __KISS__ (Keep It Simple ~~Stupid~~ Salesforce). In short, it advocates creating solutions as simple as they can be without sacrificing other values (like readability or performance).

#### YAGNI

There is also yet another popular acronym connected to the simplicity principle: __YAGNI__ (You Aren't Gonna Need It). This Extreme Programming methodology mantra adds another perspective, by stating that when creating the solution, you should build the necessary elements. Everything else is just a bloat, that makes final outcome more convoluted and error-prone.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

The simplicity focus is useful from the very start - when you are selecting the best programming language to do the job. Sure, SSJS is much more powerful and flexible than AMPScript, but unless you have a specific need for this power (YAGNI) you should go for the simpler solution (KISS) ([more on selecting SSJS vs AMPScript](../ssjs/ssjs-vs-ampscript-performance/#ampscript-vs-ssjs)).

Once you selected the best language for the job, you will have to decide on how to code the solution. And here again simplicity will be useful guideline. For example, yes, you can create universal SSJS API wrapper class, but if your script only needs to update Salesforce objects, [built-in AMPScript functions](../ssjs/ssjs-snippet-ampscript-in-ssjs/) will be enough (YAGNI) and much simpler (KISS).

Think about KISS and YAGNI whenever you are coding and it will help you deliver simpler and better solutions.

```sql
SELECT
      SubscriberKey
    , CASE
        WHEN DateJoined >= DATEADD(MONTH, -1, GETDATE())    THEN 1
        WHEN DateJoined < DATEADD(MONTH, -1, GETDATE())     THEN 0
      END AS IsNewJoiner
FROM Ent._Subscribers
/* When you only need two opposite CASE rules, simple IIF shorthand is better */
SELECT
      SubscriberKey
    , IIF(DateJoined >= DATEADD(MONTH, -1, GETDATE()), 1, 0) AS IsNewJoiner
FROM Ent._Subscribers
```

</TabItem>
<TabItem value='ui'>

The two step approach - limiting the scope (YAGNI) and selecting the easiest solution to deliver it (KISS) - can be applied to no-code solutions as well:

- When creating an email, ask yourself whether you have a specific need requiring custom HTML. If not, go for a simple Drag & Drop Blocks Template.

- When creating a segment, ask yourself whether you need multiple data sources or calculated data. If not, go for a simple filtered data extension.

- When creating a complex automation, ask yourself whether you need all those activities in a single process. If not, split it into multiple single-purpose Automations.

There are countless places in Salesforce Marketing Cloud where this approachc an be applied to the benefit of the final solution.

</TabItem>
</Tabs>

---

### Complex is better than complicated

It might sound contradictory to previous recommendation, but only on the surface. There is a limit to what can be simplified before it starts getting complicated. In such case, complex is the lesser evil.

#### SOC

When you are laser-focused on simplicity, you will feel temptation to create whole solution as one element (one script, one Automation, one Email). __SOC__ (Separation of Concerns) rule tells us that it might be wrong if said solution is build from multiple parts each with different purpose. In such case, multiple concerns stacked within a single asset will make it complicated rather then simple. The recommended solution? Split it into separate purpose-oriented elements. It will get more complex, but less complicated.

#### DRY

Another important acronym is __DRY__ (Don't Repeat Yourself). It shows a different perspective on the same problem - the simple solution that needs to be replicated multiple times, leads to a complicated outcome. Updating is huge hassle, performance is impacted, readability is poor. DRY suggests finding such repetitive spots in the solution and refactoring them.

There is also second application of the DRY principle - not solution, but work related. If you find you are doing the same thing again and again, Don't Repeat Yourself. Automate it.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

I have seen many (too many) Subscription Preference Centers in SFMC built with AMPScript. Yes, it's simple language and capable enough to deliver such solution. But because of it's simplicity, for this use case it quickly gets full of repeating script lines (DRY violation), mixes multiple purposes (SOC violation) and gets long (readability suffers).

My recommedation for most of the Preference Centers is to go with SSJS. Yes, it's more complex language than AMPScript, but with a set of tools dedicated to solving complexity. Implement SOC and make it DRY with functions & [loops](../ssjs/ssjs-loops). Bring it to the next level with splitting Front-End (Cloud Page) and Back-End (Code Resource). Versus single Cloud Page with AMPScript this solution will be more complex but much less complicated. Thus easier to debug and maintain.

</TabItem>
<TabItem value='ui'>

The same rules apply to Marketing Cloud no-code solutions. Filtered Data Extensions with Data Relationships are nice for simple segmentation, but when the segment requirements get more complicated, it's better to move to more complex SQL Queries in Automation Studio.

Similarly, you can leverage Marketing Cloud Connect and Journey Builder to update data in Salesforce CRM without any code, but when you get to the point of creating journeys with only such updates in mind - its perhaps better to go for more complex, but less complicated [AMPScript SalesforceObject](../ssjs/ssjs-snippet-ampscript-in-ssjs/#long-ampscript-code) functions.

</TabItem>
</Tabs>

---

### Flat is better than nested

When working on the solution, it is easy to build a matryoshka. Multiple goals within one asset? Let's add an [`if`/`switch`](../ssjs/js-if-and-switch) in the code, or a decision split in the Journey Builder. Edge case found during testing? Yet another `if`. Multiple goals within one email? 4-column layout is here!

This approach is natural during development, but it quickly leads to a complicated outcome. And [complicated solution should be avoided](#complex-is-better-than-complicated). There are two ways to do it:

1. __Plan__ - As Abraham Lincoln once said, 'Give me six hours to chop down a tree, and I will spend the first four sharpening the axe'. The same approach will benefit your Marketing Cloud instance.
2. __Refactor__ - Planning is awesome, but it's nearly impossible to prepare bulletproof plan. That's fine, as long as you refactor your solution after the bump in the road.

The good part? The more refactors you do, the better in planning you will become.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

loop through columns of rows example?

</TabItem>
<TabItem value='ui'>

When building in Journey Builder, it is easy to nest Decision Splits to send different communication based on some criteria, but this approach will quickly become [complicated](#complex-is-better-than-complicated) and (with how SFMC renders multiple splits) [ugly](#beautiful-is-better-than-ugly).

If the splits are added to cover more appropriate personalisation - make your Journey flat by leveraging Dynamic Content instead.

If the splits are added to cover different campaign goals - make your Journey flat by splitting each goal into separate Journey ([SOC principle](#SOC)).

</TabItem>
</Tabs>

---

### Sparse is better than dense



<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

```js title="Just because it works, doesn't mean it's worth it"
var region = country == 'UK' ? 'EMEA' : country == 'PL' ? 'EMEA' : country == 'US' ? 'AMER' : 'APAC';
/* Chained ternary operator above might be shorter, but its definitely not readable.
Making it more sparse is not only easier for the readars but also futureproof */
var region;
if (country == 'UK' || country == 'PL') {
    region = 'EMEA';
} else if (country == 'US') {
    region = 'AMER';
} else {
    region = 'APAC';
};
```

</TabItem>
<TabItem value='ui'>

</TabItem>
</Tabs>

---

### Readability counts. Naming conventions counts twice

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

One - common for all SFMC programming languages - is to follow explicit naming convention for variables, functions and columns. Strive for names that are obvious even for someone who sees the code for the first time. Saving few characters for a shorter name is not worth the time lost for deciphering the meaning later.

```js
/* You may know what it means when you write the code... */
if (ts && !tsd) tsd = new Date();

/* ... but everyone else, and even you after a week, will be thankful for explicit names */
if (isTrackingSuppressed && !trackingSuppressionStartDate) trackingSuppressionStartDate = new Date()
```

Looking for more examples of good naming? Read Style Guide recommendations for [AMPScript](../ampscript/ampscript-style-guide/#naming-convention), [SSJS](../ssjs/ssjs-style-guide/#naming-convention) and [SQL](../sql/sfmc-sql-style-guide/#explicit-vs-implicit).

</TabItem>
<TabItem value='ui'>

</TabItem>
</Tabs>

---

### Special cases aren't special enough to break the rules. Although practicality beats purity


---

### Errors should never pass silently. Unless explicitly silenced


---

### In the face of ambiguity, refuse the temptation to guess. Even when certain, test


---

### Now is better than never. Although never is often better than right now


---

### If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea


---

### Documentation is one honking great idea - let's do more of it!


---

## Sum Up