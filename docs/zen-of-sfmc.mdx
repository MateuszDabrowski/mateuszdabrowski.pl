---
id: zen-of-sfmc
title: Zen of SFMC
description: Salesforce Marketing Cloud implementation, development and operations Best Practices. In brief and in detail.
image: img/og/og-image-solve-with-cloud--page-apps.png
tags: [Marketing Cloud, Best Practice]
toc_max_heading_level: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { LeadText } from '../src/components/LeadText.js';

<LeadText content="Salesforce Marketing Cloud implementation, development and operations Best Practices. In brief and in detail." />

I'm a huge fan of Tim Petter's [PEP20 - Zen of Python](https://www.python.org/dev/peps/pep-0020/). In 19 short lines, he described his recommendations for writing good Python code. The outcome transcended the specific language and I see it as a very universal guide on software engineering.

In this article I share my Salesforce Marting Cloud adaptation and interpretation of this pearl. Expect some modifications to the original text (minimal, as most of the recommendations are perfectly valid for our Marketing Automation world), followed by my comments on how particular lines can be beneficial for SFMC practice.

## Zen of SFMC

```txt
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Naming conventions counts twice.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
Even when certain, test.
Now is better than never.
Although never is often better than right now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Documentation is one honking great idea - let's do more of it!
```

## Thoughts on Zen

Remember that those recommendations are just that - recommendations. Not strict rules, but rather a set of general - sometimes contradictory - principles, that might help you in your day-to-day work with Salesforce Marketing Cloud.

---

### Beautiful is better than ugly.

Beauty might not immediately come to the mind in the context of software development and implementation. Neither might it be in the focus in the world of short deadlines and evergrowing KPIs. However, one should not forget about beauty when deploying Marketing Cloud solutions.

It not only makes working on the tool more motivating and pleasant, but also supports a lot of other recommendations listed here - with readability in the first place. Below you can see examples of how the beauty principle can be implemented into Salesforce Marketing Cloud world.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

When you are writing code in Salesforce Marketing Cloud - be it AMPScript, SSJS, SQL, or other - you have a lot of flexibility when it comes to the structure and style. Random indentation, lack of new lines, cryptic variables? Everything is possible and might work.

But you should strive to write code that not only works. Apply beauty-focused mindset and while writing might take a bit longer, the outcome will be more readable, easier to debug and understandable to others.

```sql title="Both queries work - which one would you rather read?"
/* Beauty */
SELECT
      wel.SubscriberKey     AS SubscriberKey
    , wel.EmailAddress      AS EmailAddress
    , o.EventDate           AS OpenDate
FROM WelcomeCampaignSegment AS wel
    INNER JOIN _Open        AS o
        ON o.SubscriberKey = wel.SubscriberKey

/* and the Beast */
select a.subscriberkey, a.emailaddress, b.eventdate
from welcomecampaignsegment a join _open b on a.subscriberkey = b.subscriberkey

```

Check my Style Guides for [AMPScript](../ampscript/ampscript-style-guide/), [SSJS](../ssjs/ssjs-style-guide/), [SQL](../sql/sfmc-sql-style-guide/) to see more specific examples on how to make your code beautiful.

</TabItem>
<TabItem value='ui'>

The choice betweem beauty and ugly is not limited to writing the code. The same is true for working with Salesforce Marketing Cloud no-code tools.

Creating a Email Template using Blocks in Content Builder? Sure, you can just drag and drop the empty blocks in proper order and call it a day. But you can also put a bit more work and add sample content with predefined styles to each block, provide palceholder images with visible dimensions and save such elements as separate blocks ready for reuse.

Both approaches deliver the Email Template, but the second one does it in a more beautiful way improving the usefulness and value of the final solution.

</TabItem>
</Tabs>

---

### Explicit is better than implicit.

Salesforce Marketing Cloud enables you to decide, whether you want to create things in an implicit or explicit way. Implicit is faster and easier. Explicit is sturdier and better.

As the SFMC is long term commitmentused by many people, it's always worth to spend a bit more effort and go for explicit whenever possible. It will save you and your organisation a lot of time in the long run, so consider it an investment.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

There are a lot of tricks we can use when coding for Salesforce Marketing Cloud - implicit data type conversions, undocumented endpoints and function behaviours or just language specific synctatic sugar. As helpful as they are, they obscure readability, introduce error risk to the code and won't be known by everyone.

This is why, unless such tricks are necessary, it's good idea to go for the explicit, clear and obvious version. Even if it is slightly longer or not as sexy.

Of course, not always it will be possible - some things are only possible by coding on the edge of the documentation. Not all is lost, however, as you can make such cases more explicit with good comments. And don't limit those for just the tricky parts. Describing even the cleanest functions and scripts will help you and your team work more effectively.

```js title="'Code tells you how. Comments tell you why.' - Jeff Atwood"
/**
 * @function debugValue
 * @description Outputs provided description and SSJS value to front-end in a type-safe & consistent way
 * @param {string} description - Describes meaning of the second parameter in the output
 * @param {*} value - The value that needs to be debugged
 */
function debugValue(description, value) {
    Write(description + ': ' + (typeof value == 'object' ? Stringify(value) : value) + '<br><br>');
};
```

Read more on using comments in [SSJS](../ssjs/ssjs-style-guide/#comments) and [AMPScript](../ampscript/ampscript-style-guide/#comments).

:::note You Should Know

Explicit approach can (and should) be taken to the next level with smart use of asset Keys. They are frequently used in code - especially the Data Extension and Content Block keys. While the default pseudo-random ID does the work, I recommend going for the custom explicit Keys.

If you keep Data Extension Name and Key in sync (it might not be possible with longer names due to Key length limit) you won't have to worry about whether the Data Extension lookup is using the key or name.

But even bigger value to this approach is with Content Blocks. It's popular to use those Blocks for AMPScript snippets shared across multiple emails or brand-wide dynamic footers. Frequently they are added to the Email Templates with the help of AMPScript `ContentBlockByID` function. However, as an asset collection grows, it will be harder to remember which Content Block has been imported that way (IDs aren't helpful with that).

Explicit Content Block Key and `ContentBlockByKey` function can help with that:

```js title="Which one would you rather see in the email template?"
%%=ContentBlockByID("123456")=%%
// vs
%%=ContentBlockByKey("SharedFooterEMEA")=%%
```

:::

</TabItem>
<TabItem value='ui'>

Being explicit is not limited to the code. When working with the SFMC no-code features, you will also have a lot of places to improve your solution with a bit of added information.

A lot of assets offer one or more places to add descriptions. Data Extensions, Installed Packages, Automations - or even specific steps grouping Activities. Neither of those places _require_ a description, but each and single one will benefit from explicitly stating it's purpose and business/technical context.

There are also places where Salesforce Marketing Cloud let's you add smaller pieces of information. Not full descriptions, but rather optional micro data points that explain the purpose. Path names in Journey Builder Decision Splits. Additional Email Attribute Names in Content Builder. Collection and Cloud Page names in Web Studio. Whenever possible - spend that extra time needed to come up with explicit value.

</TabItem>
</Tabs>

---

### Simple is better than complex.

Marketing Cloud is a complex tool within a complex Salesforce ecosystem focused on solving complex business needs. But how you operate and develop SFMC should be as straightforward as possible. It will make your solution robust, agile and easily understandable.

#### KISS

This recommendation is also known in the software development community under a popular acronym: __KISS__ (Keep It Simple ~~Stupid~~ Salesforce). In short, it advocates creating solutions as simple as they can be without sacrificing other values (like readability or performance).

#### YAGNI

There is also yet another popular acronym connected to the simplicity principle: __YAGNI__ (You Aren't Gonna Need It). This Extreme Programming methodology mantra adds another perspective, by stating that when creating the solution, you should build the necessary elements. Everything else is just a bloat, that makes final outcome more convoluted and error-prone.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

The simplicity focus is useful from the very start - when you are selecting the best programming language to do the job. Sure, SSJS is much more powerful and flexible than AMPScript, but unless you have a specific need for this power (YAGNI) you should go for the simpler solution (KISS) ([more on selecting SSJS vs AMPScript](../ssjs/ssjs-vs-ampscript-performance/#ampscript-vs-ssjs)).

Once you selected the best language for the job, you will have to decide on how to code the solution. And here again simplicity will be useful guideline. For example, yes, you can create universal SSJS API wrapper class, but if your script only needs to update Salesforce objects, [built-in AMPScript functions](../ssjs/ssjs-snippet-ampscript-in-ssjs/) will be enough (YAGNI) and much simpler (KISS).

Think about KISS and YAGNI whenever you are coding and it will help you deliver simpler and better solutions.

```sql
SELECT
      SubscriberKey
    , CASE
        WHEN DateJoined >= DATEADD(MONTH, -1, GETDATE())    THEN 1
        WHEN DateJoined < DATEADD(MONTH, -1, GETDATE())     THEN 0
      END AS IsNewJoiner
FROM Ent._Subscribers
/* When you only need two opposite CASE rules, simple IIF shorthand is better */
SELECT
      SubscriberKey
    , IIF(DateJoined >= DATEADD(MONTH, -1, GETDATE()), 1, 0) AS IsNewJoiner
FROM Ent._Subscribers
```

</TabItem>
<TabItem value='ui'>

The two step approach - limiting the scope (YAGNI) and selecting the easiest solution to deliver it (KISS) - can be applied to no-code solutions as well:

- When creating an email, ask yourself whether you have a specific need requiring custom HTML. If not, go for a simple Drag & Drop Blocks Template.

- When creating a segment, ask yourself whether you need multiple data sources or calculated data. If not, go for a simple filtered data extension.

- When creating a complex automation, ask yourself whether you need all those activities in a single process. If not, split it into multiple single-purpose Automations.

There are countless places in Salesforce Marketing Cloud where this approachc an be applied to the benefit of the final solution.

</TabItem>
</Tabs>

---

### Complex is better than complicated.

It might sound contradictory to previous recommendation, but only on the surface. There is a limit to what can be simplified before it starts getting complicated. In such case, complex is the lesser evil.

#### SOC

When you are laser-focused on simplicity, you will feel temptation to create whole solution as one element (one script, one Automation, one Email). __SOC__ (Separation of Concerns) rule tells us that it might be wrong if said solution is build from multiple parts each with different purpose. In such case, multiple concerns stacked within a single asset will make it complicated rather then simple. The recommended solution? Split it into separate purpose-oriented elements. It will get more complex, but less complicated.

#### DRY

Another important acronym is __DRY__ (Don't Repeat Yourself). It shows a different perspective on the same problem - the simple solution that needs to be replicated multiple times, leads to a complicated outcome. Updating is huge hassle, performance is impacted, readability is poor. DRY suggests finding such repetitive spots in the solution and refactoring them.

There is also second application of the DRY principle - not solution, but work related. If you find you are doing the same thing again and again, Don't Repeat Yourself. Automate it.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

I have seen many (too many) Subscription Preference Centers in SFMC built with AMPScript. Yes, it's simple language and capable enough to deliver such solution. But because of it's simplicity, for this use case it quickly gets full of repeating script lines (DRY violation), mixes multiple purposes (SOC violation) and gets long (readability suffers).

My recommedation for most of the Preference Centers is to go with SSJS. Yes, it's more complex language than AMPScript, but with a set of tools dedicated to solving complexity. Implement SOC and make it DRY with functions & [loops](../ssjs/ssjs-loops). Bring it to the next level with splitting Front-End (Cloud Page) and Back-End (Code Resource). Versus single Cloud Page with AMPScript this solution will be more complex but much less complicated. Thus easier to debug and maintain.

</TabItem>
<TabItem value='ui'>

The same rules apply to Marketing Cloud no-code solutions. Filtered Data Extensions with Data Relationships are nice for simple segmentation, but when the segment requirements get more complicated, it's better to move to more complex SQL Queries in Automation Studio.

Similarly, you can leverage Marketing Cloud Connect and Journey Builder to update data in Salesforce CRM without any code, but when you get to the point of creating journeys with only such updates in mind - its perhaps better to go for more complex, but less complicated [AMPScript SalesforceObject](../ssjs/ssjs-snippet-ampscript-in-ssjs/#long-ampscript-code) functions.

</TabItem>
</Tabs>

---

### Flat is better than nested. Sparse is better than dense.

When working on the solution, it is easy to build a matryoshka. Multiple goals within one asset? Let's add an [`if`/`switch`](../ssjs/js-if-and-switch) in the code, or a decision split in the Journey Builder. Edge case found during testing? Yet another `if`. Multiple goals within one email? 4-column layout is here! KPIs for leads, sales, loyalty and brand are not yet met? Let's hit them with a welcome Journey.

This turn of events is natural during development, but it quickly leads to a complicated outcome. And [complicated solution should be avoided](#complex-is-better-than-complicated), because they work worse then single purpose focused ones. There are two ways to do it:

1. __Plan__ - As Abraham Lincoln once said, 'Give me six hours to chop down a tree, and I will spend the first four sharpening the axe'. The same approach will benefit your Marketing Cloud instance.
2. __Refactor__ - Planning is awesome, but it's nearly impossible to prepare a bulletproof plan. That's fine, as long as you refactor your solution after the bump in the road.

Following those steps will help you create simpler, lighter and better solutions. And the more refactors you do, the better in planning you will become.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

It's easy to write deeply nested code. It's even easier to write dense code, full of synctatic sugar that is short and looks 'professional'. Especially when copy pasting a magical solution found on the Stack Overlow (been there, done that).

However, the good code doesn't have to be short or prove that you know all quirks of the language. The good code must be [readable](#readability-counts-naming-conventions-counts-twice), [simple](#simple-is-better-than-complex) and [explicit](#explicit-is-better-than-implicit). And in many cases it will be a bit longer and from simpler building blocks.

```js title="Just because it works, doesn't mean it's worth it"
var region = country == 'UK' ? 'EMEA' : country == 'PL' ? 'EMEA' : country == 'US' ? 'AMER' : 'APAC';
/* Chained ternary operator above might take less lines of code, but its definitely not readable.
Making it more sparse and flat is not only easier for the readars but also futureproof */
if (country == 'UK' || country == 'PL') {
    var region = 'EMEA';
} else if (country == 'US') {
    var region = 'AMER';
} else {
    var region = 'APAC';
};
```

</TabItem>
<TabItem value='ui'>

When building in Journey Builder, it is easy to nest Decision Splits to send different communication based on some criteria, but this approach will quickly become [complicated](#complex-is-better-than-complicated) and (with how SFMC renders multiple splits) [ugly](#beautiful-is-better-than-ugly).

If the splits are added to cover more appropriate personalisation - make your Journey flat by leveraging Dynamic Content instead.

If the splits are added to cover different campaign goals - make your Journey flat by splitting each goal into separate Journey ([SOC principle](#SOC)).

The same is true for Emails that frequently like to grow due to multiple KPIs being applied to them. Sure, you can cram a lot if you go for 4-column layout with multiple sections, but the layout bugs will emerge, deliverability will suffer, readability will tank and the reader will get lost in the number of call to actions. Instead, focus on one concrete and targeted action that is crucial for your business.

</TabItem>
</Tabs>

---

### Readability counts.

Readability is key. In code, it limits bugs, simplifies debugging, improves future development and saves tons of time. In content, it's key to drive the message to the recipient. In short, without readability, there is no value.

I have already written a lot about readability of Marketing Cloud programmatic langauges: [AMPScript](../ampscript/ampscript-style-guide/), [SSJS](../ssjs/ssjs-style-guide/), [SQL](../sql/sfmc-sql-style-guide/).

As for the readability of content:

1. Write short sentences (15 words is nice; stay under 30).
2. Use simple language (instead of `due to the fact that` use `because`).
3. Prove with hard data (instead of `significant amount of customers recommends` use `93% of customer recommends`).
4. Cut marketing fluff (every part of the content should have an asnwer to `so what?` question).
5. Proof-read. Proof-read again.

---

### Naming conventions counts twice.

I love naming conventions and believe they are crucial to long term success of marketing automation solutions. They improve readability and maintainability, they bring clarity and unlock even more automation possibilities.

What is special about them is that they provide most value when implemented from the very start and enforced everywhere. But if you are thinking long term (and with Marketing Automation tools - you should), it's better to implement one late then never. The bigger and older the solution, the stronger you will feel that good naming convention is more of a must-have then nice-to-have.

<Tabs
    defaultValue={null}
    values={[
        {label: 'SFMC Code Example', value: 'code'},
        {label: 'SFMC UI Example', value: 'ui'},
    ]}
>
<TabItem value='code'>

You can benefit from implementing a naming convention in all SFMC programming languages. Strive for variable, function, column names that are obvious even for someone who sees the code for the first time. Saving few characters for a shorter name is not worth the time lost for deciphering the meaning later.

```js
/* You may know what it means when you write the code... */
if (ts && !tsd) tsd = new Date();

/* ... but everyone else, and even you after a week, will be thankful for explicit names */
if (isTrackingSuppressed && !trackingSuppressionStartDate) trackingSuppressionStartDate = new Date()
```

Looking for more examples of good naming? Read Style Guide recommendations for [AMPScript](../ampscript/ampscript-style-guide/#naming-convention), [SSJS](../ssjs/ssjs-style-guide/#naming-convention) and [SQL](../sql/sfmc-sql-style-guide/#explicit-vs-implicit).

</TabItem>
<TabItem value='ui'>

Naming convention is huge when working with the Salesforce Marketing Cloud. Leveraging a proper one not only makes it much easier to differentiate assets and make searching for them easier. It's also an awesome tool to enable some smart personalisations and checks in email communication (with the help of the `%%emailname_%%` personalisation string). That's not all - good naming convention improves greatly value coming from System Data Views and reporting.

With all this praise - what is a good naming convention for the markating automation assets? This of course depends on the specifics of your business, but my recommendation is to mix shortcuts for data filled elements and clear separators.

My favourite approach is to:

1. Define set of business-oriented data points that bring value.
2. Create readable shortcuts for them to limit the final length of the naming convention.
3. Create a dedicated space for each separate element in the naming convention.
4. Split the elements with underscore (`_`).
5. Split parts of single element with hyphen (`-`).

That's theory, but what are good business-oriented data points? Some examples I frequently use are:

- Country (if you are operating in multiple markets)
- Business Unit (if you have complex internal structure of the company)
- Segment (if you have set of predefined master-segments / personas)
- Campaign Type (it's always useful)
- Free-text Asset Name (the human-readable part that helps easily understand the purpose)
- Asset Type (can help in Content Builder to differentiate various partial assets)
- Date (useful especially if you are creating a lot of simillar assets for recurring goals)
- Campaign Code (or whatever you are using for closed-loop reporting and 360 analytics)

How does it translate for the final name? Let's check example:

`UK_DEV_C_WEL_brand-welcome-1_EML_21-10_01234`

It's elements would be:

1. Country: `UK` = United Kingdom
2. Business Unit: `DEV` = Development
3. Segment: `C` = Customers
4. Campaign Type: `WEL` = Welcome
5. Asset Name: `brand-welcome-1`
6. Asset Type: `EML` = Email
7. Date: `21-10` = October 2021
8. Campaign Code: `01234`

As you can see, with under 50 characters we captured 8 different data points and quite good picture of the purpose of the asset.

What is more, Business Intelligence team will be able to do a simple split by underscore to capture each element as separte category to enable filtering and grouping in reporting.

</TabItem>
</Tabs>

---

### Special cases aren't special enough to break the rules. Although practicality beats purity.

Those contradictory lines are following the ancient greek golden middle way philosophy. The thought behind them is quite straightforward. Whenever you decide to stick to some recommendation or rule (be it from this article or else) - fight the temptation to create exceptions to it when you encounter first bump on the road.

Sure, it might be easier to ignore it when the deadline is near or you have too much to do. It's easy to say "I will align it later". But there is always more work to be done "later", and in the end you end up with a messy solution that doesn't provide the value promised by following the rules. However, following the rules to the book in every single case might be an overkill that stops you from delivering a working solution at all.

That's why you must not only learn how to follow the rules, but also when to break them.

---

### Errors should never pass silently. Unless explicitly silenced.



---

### In the face of ambiguity, refuse the temptation to guess. Even when certain, test.


---

### Now is better than never. Although never is often better than right now.


---

### If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea.


---

### Documentation is one honking great idea - let's do more of it!

---

## Sum Up