---
id: js-dom
title: JS Document Object Model
sidebar_label: DOM
description: WIP
image: img/og/og-image-js-dom.png
tags: [JavaScript, Cloud Page, Personalisation]
---

import { LeadText } from '../../src/components/LeadText.js';

<LeadText content='WIP' />

## What is Document Object Model?

The Document Object Model (DOM) represents the structure of a web document and serves as its programming interface. In simpler words, it let's JavaScript talk with the HTML of the page. And that is huge, especially in Marketing Automation world.

Why? Because it let's you manipulate your website in many ways - visible and not. Dynamic forms adapting to user actions, pages changing in real time and enhanced data capture. All that is possible thanks to DOM. So let's dive into details.

## Accessing the DOM

To start working with Document Object Model in JavaScript, you need to use one of the special objects - `window` (browser tab) or `document` (page within that tab). Each of those objects offer multitude of methods that let you interact with a webpage.

JavaScript lets you capture specific parts of your website and make them accessible for all your scripting needs with the help of `document` object methods:

- __getElementById__: returns an element with matching id (for example, `document.getElementById('emailAddressField')`)
- __getElementsByTagName__: returns a collection of matching tags (for example, all `document.getElementByTagName('p')` tags)
- __getElementsByName__: returns a collection of tags with matching name (for example, all inputs with name `document.getElementByName('email')`)
- __getElementsByClassName__: returns a collection of tags with matching class (for example, all tags with class `document.getElementByClassName('hiddenContent')`)
- __querySelector__: returns an element with a matching CSS3 selector (for example `document.querySelector('#mainContent .hiddenContent h2')` - notice the `#` prefix for id and `.` for a class). If there are multiple matching elements - it will return the first one.
- __querySelectorAll__: returns a collection of elements matching CSS3 selector (for example `document.querySelectorAll('#attributes-repeater .DataCell tr')`)

:::note You Should Know

`querySelector` and `querySelectorAll` allows you to select elements using the power of CSS3. It means that you can go really specific with he right syntax.

You can select:
1. Tag by its name: `document.querySelector('body')`
2. Id with `#` prefix: `document.querySelector('#idName')`
3. Class with `.` prefix: `document.querySelector('.className')`
4. Tag with specific class by chaining: `document.querySelector('div.className')`
5. Element with two classes: `document.querySelector('.className1.className2')` (notice lack of space between classes)
6. Element that is direct child of another element: `document.querySelector('div > h2')`
7. Element that is any child another element: `document.querySelector('div h2')`
8. Element that is any sibling (has the same parent): `document.querySelector('p.className ~ h2')` (this will capture `h2` that is under the same parent as `p.className`)
9. Element that is adjecent sibling (has the same parent): `document.querySelector('p.className + h2')` (this will capture `h2` that is under the same parent as `p.className` and after that paragraph)
10. Element with specific attribute: `document.querySelector('[href]')`
11. Element with specific value of attribute: `document.querySelector('input[type="checkbox"]')`
12. One of the listed elements: `document.querySelector('ul, ol')`
13. All of the listed elements: `document.querySelectorAll('ul, ol')`
14. Elements targetet by [pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes): `document.querySelectorAll('a:visited')`
15. [Pseudo-element](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements): `document.querySelectorAll('h1::first-letter')`
16. Element with negated selection: `document.querySelector('.className:not(div)')`

Sky is the limit, especially with chaining all of the above into single super query:

```js
document.querySelector('#content > article > div:nth-child(20) a:nth-child(1) > code');
```

However, whenever possible, optimise. Either by finding a better way to select the element or (if possible) by adding easily selectable attribute to that element in the page HTML.

:::

As you can see, there are a lot of options you can leverage.

### Should you use getElement or querySelector?

The rule of thumb is that if one of the `getElement` selectors can do the job, it's better choice due to optimised performance (the longer HTML, the bigger difference). However, for more complex selections it might either be better or even the only possible choice to use the newer `querySelector` family.

```js title="Good use cases for the querySelector family"
// Instead of using three getElement selectors (that wouldn't even work in this example)
document.getElementById('attributes-repeater').getElementsByClassName('DataCell').getElementsByTagName('tr');
// you should use a single querySelectorAll selector
document.querySelectorAll('#attributes-repeater .DataCell tr');

// There are also cases where querySelector is the only choice
document.querySelectorAll('input[type="checkbox"]');
```

As always, the devil lies in the details. While chained `getElement` selectors will have better performance than clean `querySelector`, there are three issues with the former:

1. Readability: after two or three selectors the `getElement` chain gets really hard to read and debug, natural CSS3 style of `querySelector` is much more straightforward.
2. Flexibility: you can only chain `getElements` on single elements. Refering to the previous code sample, while the `.getElementsByClassName('DataCell')` called on single outcome of `.getElementById('attributes-repeater')` works, returned collection of outcomes would crash the `.getElementsByTagName('tr')`.
3. Loopability: outcomes of `getElements` selection cannot be looped using [`forEach()`](./js-loops.mdx#foreach).

So my approach is to use the more flexible and readable `querySelector` whenever performance is not a dealbraker, and switch where possible to `getElement` toolset when the performance is crucial.

:::note You Should Know

You can assign your DOM selection to a variable. It not only allow you to reuse it in multiple places of your script, but also let's you limit the scope of the selection.

You can do the latter by replacing the `document` object with your variable - it will look for matching DOM elements only within the outcome of the previous seletion.

```js
const form = document.querySelector('form');
const divsInForm = form.querySelectorAll('div.legalNotice'); // Returns only div tags with legalNotice class that are within your form
```

It works like chaining selectors and with the same limitation - you can chain only if previous outcome is single element.

```js
/* ✅ Chain from a single element to a collection - same outcome as previous code snippet */
document.querySelector('form').querySelectorAll('div.legalNotice');

/* ❌ Chain from a collection to a collection - will throw TypeError */
document.querySelectorAll('form').querySelectorAll('div.legalNotice');

/* ✅ Chain from a single element (thanks to index) to a collection */
document.querySelectorAll('form')[0].querySelectorAll('div.legalNotice');

/* Of course, in real scenario, you should use a compound selector for the same result */
document.querySelectorAll('form div.legalNotice');
```

:::

Selecting elements is just the beginning. Once you pick them, you can [explore](#exploring-the-dom), [traverse](#traversing-the-dom) and [manipulate](#manipulating-the-dom) the DOM. You can check what is available for selected element with `console.dir(selectedElement)` in the developer console.

## Exploring the DOM

Once you select the page element, you can learn more about it thanks to properties and methods. There is a [long list](https://developer.mozilla.org/en-US/docs/Web/API/Element]) of available features, so let's focus on the ones most useful in marketing automation and real-time personalisation space.

### .attributes

With `.attributes` property you can list all HTML attributes on selected element as a NamedNodeMap. What is more, you can drill down on those details to get specific values:

```js
/* <main id="content" class="main-content" role="main">…</main> */
document.querySelector('#content').attributes;              // returns a Map with id, class and role
document.querySelector('#content').attributes.class.value;  // returns 'main-content'
```

While it is great way of learning what attributes are used on a specific elements, in most scenarios the attribute-specific shorthand properties will be much more useful.

### .classList and .className

The `.classList` property let's you directly list all classes assigned to the selected element (in a form of DOMTokenList). It is great when you want to [loop](./js-loops.mdx) through to find a specific class or [manipulate the DOM](#manipulating-the-dom).

On the other hand, when you want to do a simple [check or condition](./js-if-and-switch.mdx), `.className` is a great shorthand returning a string with all classes.

```js
/* <div class="page-wrapper category-api document-page">…</div> */
document.querySelector('div.page-wrapper').classList;                           // returns an object with all the classes, length and value
document.querySelector('div.page-wrapper').classList.contains('document-page'); // returns true
document.querySelector('div.page-wrapper').classList.value;                     // returns 'page-wrapper category-api document-page'
document.querySelector('div.page-wrapper').className;                           // shorthand of the previous, returns 'page-wrapper category-api document-page'
```

The `.classList` property is the bread and butter of page manipulation, as it allows you to add, remove, replace and toggle classes on an element. Think of hiding and displaying elements, changing the styles and other dynamic scenarios. More on that, in the [Manipulating the DOM](#manipulating-the-dom) section.

### .id and .tagName

Similarly to class-related properties, there is `.id` property that returns the value of id attribute and `.tagName` property that returns name of the selected tag.

```js
/* <main id="content" class="main-content" role="main">…</main> */
document.querySelector('.main-content').id;      // returns 'content'
document.querySelector('.main-content').tagName; // returns 'main'
```

Those two are less frequently used and mostly have some value when [travelling through the DOM](#traversing-the-dom).

### .innerText and .innerHTML

Another extremly important properties are `.innerText` and `.innerHTML`. They allow you to look into what is within the selected element.

`.innerText` returns a plain text version of element content (including all child tags within). Think the result of copy pasting fragment of the page into a chat.

```js title="Example output for header of this section"
document.querySelector('#innertext-and-innerhtml').innerText;
// returns ".innerText and .innerHTML"
```

`.innerHTML`, on the other hand, will return a full blown HTML code of the selected element (including all child tags within). Keep in mind, however, that it will be the rendered HTML, not the original HTML (so the version adapted to your screen, your device, your context).

```js title="Example output for header of this section"
document.querySelector('#innertext-and-innerhtml').innerHTML;
// returns ".innerText and .innerHTML<a class=\"hash-link\" href=\"#innertext-and-innerhtml\" title=\"Direct link to heading\"></a>"
```

While it is already useful, those properties shine when you want to [manipulate your page](#manipulating-the-dom). More on that later.

### .hidden and .style

Finally, there are landing page must-haves - `.hidden` and `.style`. Those two properties describe the CSS of the selected element.

`.hidden` is straightforward. It returns a boolean telling you whether the element is hidden from the frontend of the page.

`.style` is much deeper, as it returns a whole object build with all possible __inline__ CSS declarations for the element. You can then drill down to return a value of specific declaration.

```js title="Example output for header of this section"
document.querySelector('#hidden-and-style').hidden;         // returns false
document.querySelector('#hidden-and-style').style.display;  // returns ''
```

As with other properties mentioned previously, those true shine when [manipulating the DOM](#manipulating-the-dom).

## Traversing the DOM

Think about the DOM as a complex hierarchy of elements. When you select specific element, it is located somewhere within that hierarchy. And with the help of properties and methods you can travel through that web.




## Manipulating the DOM



