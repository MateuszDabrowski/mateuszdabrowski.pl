---
id: mcp-serverside-code-context
title: MCP Serverside Code Context
sidebar_label: Serverside Code Context
description: "Context is king. Also when writing MCP Template Serverside Code."
image: img/og/og-image-mcp-serverside-code-context.png
tags: [Marketing Cloud, Marketing Cloud Personalization, Interaction Studio, Personalisation, TypeScript]
---

import { LeadText } from '../../src/components/LeadText.js';

<LeadText content="Context is king. Also when coding MCP Campaign Templates. Read about all its undocumented tricks." />

Marketing Cloud Personalization offers a flexible campaing template creation tooling with multiple [properties](./mcp-serverside-code-properties.mdx) and imports that helps you fulfil the business needs with a nice user experience for the marketer. There is also one more - undocumented - feature that can change your template from good to outstanding. The CampaignComponentContext object.

:::note You Should Know

In this article I'm covering the main `CampaignComponentContext` object that is being passed as a `context` argument to the [`run` method](./mcp-serverside-code-basics.mdx#writing-serverside-code) in the Serverside Code of every campaign template.

There are some other contexts (like `GearLifecycleContext` passed to search methods), that have different structure and are out of the scope of this article.

:::

The `CampaignComponentContext` object is available in the Serverside Code of the Web, Serverside and Triggered Campaign Templates and provides extensive details about triggering event, user and delivered experience.

```js title="Structure of the context object"
{
    "campaignId": string,
    "experienceId": string,
    "userGroup": string,
    "beaconVersion": number,
    "event": Object,
    "contentZone": string,
    "trigger": Object,
    "locale": string,
    "services": Object,
    "user": Object,
    "accountId": string,
    "datasetId": string,
    "configuration": Object
}
```

It's extremely easy to use once you know what's in there. For example, you can pull product ID stored with Sitemap in a User Attribute and leverage it to pull full data about that product for personalization:

```ts {2-3} title="Leverage context in the run method of your Serverside Code"
    run(context: CampaignComponentContext) {
        let lastAddedToCartProductId = context.user.attributes?.lastAddedToCartProduct?.value;
        let lastAddedToCartProductDetails = context.services.catalog.findItem('Product', lastAddedToCartProductId);
        return { lastATCDetails: lastAddedToCartProductDetails };
    }
```

And that's just a basic usage. The key to unlocking the power of context object is knowing what is stored there and how it can be used. So let's dive in, property by property (hint, the fun part starts at [`event`](#event)).

:::note You Should Know

This article is in a work in progress state - I'm ongoingly extending details about various parts of the context object as I have opportunity to use it in real-life.

:::

## campaignId & experienceId

First two string properties of the context object are `campaignId` and `experienceId` and their purpose if very strightforward. They provide the five character, case sensitive, alphanumerical ids for the campaign and experience selected for a user (for example, `vALdQ` for Campaign ID and `f3WpK` for Experience Id).

Both those values are passed by default from serverside to clientside and handlebars (as `campaign` and `experience` accordingly) so there is no much added value in those two unless you want to append those values as query strings to the links for tracking purposes.

However, for Web Campaigns you can do it easily within the handlebars tab and for Serverside and Triggered Campaigns - do it on the receiving system side.

## userGroup

`userGroup` string property should tell you to which user group the user got assigned. Well, should. In practice you will see there one of the two values: `Test` for users that got an A/B Test or Rule-Based experience and `testUserGroup` for those that are in Control group (or in Template preview pane within MCP UI).

However, you will see better values in the out-of-the-box serverside payload `userGroup` property that shows values like `Test`, `Default`, `Control` correctly and only displays `testUserGroup` during preview.

:::note You Should Know

Control group creates more problems for the context, as it returns the payload preview version of it. So you will also see only the placeholder values for [`campaignId` and `experienceId`](#campaignid--experienceid), [`beaconVersion`](#beaconVersion) and skip other datapoints like [`event.fields`](#event).

In short, don't use `context` for custom payload dedicated to control group users.

:::

## beaconVersion

`beaconVersion` number property will display current Web SDK version (f.e. `16` at the moment of writing it) or `0` for preview/control group. Not really useful.

## event

`event` object property is where the magic of the `context` object starts. It stores information related to the event that triggered the campaign - the data that you can see when you leverage `.setLoggingLevel('debug')` method in your Sitemap.

:::note You Should Know

The `context.event` object won't work correctly in the Template Preview sidebar, as there is no valid event in that mode. Use an active campaign directly on the website the preview the real output during development. Just make sure you use the campaign targeting to limit execution just to you.

:::


```js title="Structure of the context.event object"
{
    "time": datetime,
    "fields": Object,
    "ipAddress": (): string,
    "itemId": (): string,
    "itemType": (): string
}
```

While the `context.event.time` is not that useful (unless you want to make some time-dependent changes to the camapign payload), the three functions available there are much more practical:

1. `context.event.ipAddress()` returns an IP address of the user visiting your website. You might use it to blocklist specific IP ranges (be it internal or competitors) from seeing your camapigns. It's not a clean solution (as the campaign needs to be executed to get this far), but as there is no MCP-level IP blocklist, this might be your best bet. Of course, much better solution would be to build such logic on the website side to conditionally block IPs already on the Web SDK import step, but that might not be always possible.
2. `context.event.itemId()` returns the ID of the Catalog Item that was viewed in the event. It pairs perfectly with the next function:
3. `context.event.itemType()` returns the Catalog of the Item that was viewed (f.e. `'Product'` for Product View).

The pair of `itemId` and `itemType` are really useful, as those two details are exactly what is required for a [`context.services.catalog.findItem()`](#servicescatalog) call that let's you get full details about the currently displayed item. It enables use cases where you want to change campaign payload based on dispalyed item attributes, related catalog objects or other details available on the full item detail. For example - access to [localized item data](#locale).

:::note You Should Know

Event is not only a nice datapoint that you can access through `context`, it is also the basis for the anchor in Einstein Recipes. You can leverage it (in a very dirty way) to create fake anchors and deploy recommendations for products related to the one currently viewed.

:::

On top of the above `context.event` contains also `context.event.fields` subobject capturing even more details about the triggering event.

### event.fields

```js title="Structure of the context.event.fields object"
{
    ".anonId": string,
    ".bv": string,
    ".pv": boolean,
    ".scv": number,
    ".skipProcessing": boolean,
    "action": string,
    "channel": string,
    "clientIp": string,
    "contentZones": string[],
    "pageType": string,
    "url": string,
    "urlref": string,
    "userAgent": string,
    "_anon": boolean,
    "_debug": boolean,
    "customAttribute1": any,
    "customAttribute2": any
}
```

`context.event.fields` subobject groups multiple datapoints, many of which are very technical and not really useful for us. But there are some that can open interesting use cases - let's dive in.

1. `context.event.fields.pageType` returns the name of the currently viewed page type as configured in the Sitemap (f.e. `'Home'`).
2. `context.event.fields.action` returns the name of the currently pushed action as configured in the Sitemap (f.e. `'Viewed Home'`, albeit it is much more interesting for custom actions that can drive different campaign experiences despite being triggered on the same page type).
3. `context.event.fields.url` returns the URL where the event originated. The cool part is that it contains the hash and query strings, so you can drive use cases using those elements (f.e. change the experience based on query string valus that you set in the email campaign using SFMC data).
4. Apart from those always-there properties, you will also see there custom attributes that you passed along with the event. For example, if in the sitemap you are passing SFMC Contact Key along with the event: `actionEvent.user.attributes.sfmcContactKey = queryParameters.get('sk');` you will have `context.event.fields.sfmcContactKey` property available with that value. This is huge - it enables us to build campaigns that are leveraging real-time data. Use cases? Sure! Create an `hasAddedInsurance` attribute filled on Add to Cart event to know whether you want to promote a cross-sell. Add `hasMetFreeDeliveryThershold` to conditionally trigger recommendations of products that will help the customer get over the line of free delivery.

## contentZone

`contentZone` string property returns the Content Zone that was selected for the Campaign. It might be useful if your campaign supports multiple content zones and you want to alter some payload elements based on the one selected (f.e. change the number of returned recommenations):

```ts {2} title="Leverage context.contentZone to change the serverside payload"
// Limit the number of recommendations to first four for smaller placements
if (['search_see-more', 'listing_see-more'].includes(context.contentZone)) {
    recommenations = recommendations.slice(0,4);
}
```

## trigger

`trigger` object property is filled in only for the Triggered Campaign Templates.

ðŸš§ Work in progress ðŸš§

## locale

If you have switched on Locale support in your Marketing Cloud Personalization, `locale` string will return a five-characters long combination of ISO language code and ISO country code (`language_COUNTRY`, for example: `en_US` for american english).

You can use it to return the campaign content based on the most recent user locale (be it based on manually entered variations in the Campaign configuration or by pulling directly from the localized Catalog):

```ts {7} title="Leverage context.locale to pull localized product details"
const recommendedIds = recommendIdsOnly(context, recipeConfig);
// Return localized recommendations with key datapoints needed for the campaign
let localisedRecommendations = context.services.catalog
    .findItems('Product', recommendedIds)
    .map(product => product.toFlatJSON(
        ['id', 'name,' 'imageUrl', 'url', 'price'],
        context.locale || ''
    ))
```

## services

```js title="Structure of the context.services object"
{
    "catalog": Object,
    "recommendations": Object,
    "smartTrends": Object,
    "surveys": Object,
    "decisions": Object,
    "corvus": Object,
    "promotionCatalog": Object
}
```

### services.catalog

```js title="Structure of the context.services.catalog object"
{
    "dimensionFilter": (dimension: string): ItemFilter<any>,
    "findClosestItems": (request: ClosestItemsRequest): Item[],
    "findItem": (type: string, id: string): Item,
    "findItems": (type: string, ids: string[]): Item[] || (type: ItemFilter<any>, ids: ItemSort<any>): Item[] || (type: ItemFilter<any>): Item[]
}
```

### services.recommendations


```js title="Structure of the context.services.recommendations object"
{
    "recommend": (request: RecommendationsRequest): Item[],
    "recommendIdsOnly":  (request: RecommendationsRequest): Item[],
    "smartSearch": (request: SmartSearchRequest): Item[],
    "smartSort": (request: SmartSort): Item[]
}
```

### services.smartTrends

```js title="Structure of the context.services.smartTrends object"
{
     "smartTrends": (request: SmartTrendsRequest): ItemTrends[]
}
```

ðŸš§ Work in progress ðŸš§

### services.surveys

```js title="Structure of the context.services.surveys object"
{
     "getSurey": (surveyId: string): Survey
}
```

ðŸš§ Work in progress ðŸš§

### services.decisions

```js title="Structure of the context.services.decisions object"
{
     "decide": (request: ContextualBanditRequest): Item[]
}
```

### services.corvus

```js title="Structure of the context.services.corvus object"
{
    "contextualBandit": {
        "decide": (request: ContextualBanditRequest, filter: PromotionFilter): Item[]
    }
}
```

### services.promotionCatalog

```js title="Structure of the context.services.promotionCatalog object"
{
    "findPromotions": (filter: ItemFilter<any>, context: CampaignComponentContext): Promotion: [],
    "promotionFilter": (contentZone: string): PromotionFilter
}
```

## user


```js title="Structure of the context.user object"
{
    "attributes": Object,
    "profileObjects": Object,
    "visits": [Object],
    "orderHistory": [Object],
    "location": Object,
    "currentCart": Object,
    "anonymous": boolean,
    "segmentMembership": [Object],
    "id": string,
    actionCount: (request: ActionStatsRequest): number, // {actionName: 'Action Name'}
    actionCountPerItem:  (request: ActionStatsRequest): number, // {actionName: 'Action Name'}
    getDimensionActivity: (dimension: string, start: Date, end: Date): {
        [itemId: string]: ItemActionStats
    }, // 'Product', new Date('2023-08-23T23:30:58.937Z'), new Date('2023-08-24T08:30:58.937Z')
    getDimensionActivityByDay: (dimension: string, start: Date, end: Date): {
        [date: string] : ItemActionStats
    },
    getEmailSendHistory: (start: Date, end: Date): EmailSendActivity[] || (): EmailSendActivity[],
    getLatestOrderByStatus: (status: 'Open' | 'Purchased' | 'Cancelled'): Order,
    getSegmentJoinDate: (segmentId: string): Date,
    itemStatTotal: (request: ItemStatsRequest): number, // (itemId?: string, itemType: string, statType: ItemStatType)
    itemStatTotalPerItem: (request: ItemStatsRequest): ItemStat[], // (itemId?: string, itemType: string, statType: ItemStatType)
    pageViewCount: (request: StatsRequest): number, // {start: Date, end: Date}
    visitCount: (request: StatsRequest): number, // {start: Date, end: Date}
    visitDurationMillis: (request: StatsRequest): number, // {start: Date, end: Date}
}
```

### user.attributes

```js title="Structure of the context.user.attributes object"
{
    "created": {
        "value": number // epoch
    },
    "customAttribute": {
        "value": any
    },
    "originatingReferrer": {
        "value": "{\"medium\":\"Direct\",\"source\":null,\"terms\":null,\"domain\":null,\"subdomainReversed\":null,\"url\":null,\"landingUrl\":\"https://www.mateuszdabrowski.pl/\"}"
    },
    "firstName": {
        "value": string
    },
    "lastViewedCartAt": {
        "value": number // epoch
    },
    "firstActivity": {
        "value": number // epoch
    }
}
```

### user.profileObjects

ðŸš§ Work in progress ðŸš§

### user.visits

```js title="Structure of the context.user.visits array"
[
    {
        "start": number, // epoch
        "lastEventTime": number, // epoch
        "timeSinceLastVisit": number, // miliseconds
        "referrer": { // || null
            "medium": "Direct",
            "source": null,
            "terms": null,
            "domain": null,
            "subdomainReversed": null,
            "url": null,
            "landingUrl": "https://www.mateuszdabrowski.pl/"
        },
        "deviceType": "Computer",
        "browser": "Chrome",
        "platform": "Web",
        "operatingSystem": "Windows",
        "weather": { // || null
            "temperature": 71,
            "humidity": 67,
            "windSpeed": 7,
            "rain3h": 0,
            "snow3h": 0,
            "cloudCoverage": 0,
            "condition": {
                "id": 800,
                "name": "clear sky",
                "icon": "01d",
                "category": "Clear"
            }
        },
        "pageViewIndex": 9
    }
]
```

### user.orderHistory

```js title="Structure of the context.user.orderHistory array"
[
     {
        "id": null,
        "created": number, // epoch
        "updated": number, // epoch
        "purchaseDate": null,
        "visitAgeAtPurchase": number, // miliseconds
        "totalValue": number,
        "totalValueCurrency": null,
        "status": "Open",
        "metadata": null,
        "lineItems": [
            {
                "quantity": number,
                "price": number,
                "itemId": string,
                "attributes": {}
            },
        ],
        "attributes": {}
    }
]
```

### user.location

```js title="Structure of the context.user.location object"
{
    "geographicPoint": {
        "latitude": number,
        "longitude": number
    },
    "timeZoneId": "Europe/Warsaw",
    "continentKey": "EU",
    "countryCode": "PL",
    "countryNumericCode": 616,
    "stateProvinceCode": "14",
    "city": "Warsaw",
    "postalCode": "00-633",
    "organization": "Pwc Polska Sp. Z O.o.",
    "naicsCode": "517311"
}
```

### user.currentCart

```js title="Structure of the context.user.currentCart object"
{
    "id": null,
    "created": number, // epoch
    "updated": number, // epoch
    "purchaseDate": null,
    "visitAgeAtPurchase": number, // miliseconds
    "totalValue": number,
    "totalValueCurrency": null,
    "status": "Open",
    "metadata": null,
    "lineItems": [
        {
            "quantity": number,
            "price": number,
            "itemId": string,
            "attributes": {}
        },
    ],
    "attributes": {}
}
```

### user.segmentMembership

```js title="Structure of the context.user.segmentMembership array"
[
     {
        "segmentId": string,
        "segmentName": string,
        "joined": number, // epoch
        "createIfMissing": boolean,
        "removal": boolean,
        "userId": string,
        "customerId": string,
        "customerType": "User"
    }
]
```

## accountId & datasetId

`accountId` and `datasetId` are string properties that contain information about the Marketing Cloud Personalization account and dataset that generated the event. Not really useful, unless you want environment aware debug log visibility logic.

## configuration

`configuration` object property contains information about the campaign properties (fields you expect marketer to fill in when configuring the campaign) in the experience for a given user. Not really useful, as in the serverside code you can access the same information using `this` keyword (f.e. `this.campaignPropertyName`).