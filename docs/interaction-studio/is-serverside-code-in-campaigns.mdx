---
id: is-serverside-code-in-campaigns
title: Serverside Code in IS Campaigns
sidebar_label: Serverside Code
description: ""
image: img/og/og-image-interaction-studio-serverside-code.png
tags: [Interaction Studio, Personalisation, TypeScript]

---

import { LeadText } from '../../src/components/LeadText.js';
import Image from '@theme/IdealImage';
import purpose from '../../static/img/article/article-image-is-serverside-purpose.png';
import templateUi from '../../static/img/article/article-image-is-serverside-template-ui.png';

<LeadText content="" />

## IS Serverside Code Purpose

Whether you are creating a Web, Serverside or Triggered Campaign Template in the Interaction Studio (Marketing Cloud Personalization), in each case you will start with the Serverside Code tab. It is true core of the platform responsible for delivering data-driven personalizations.

This is the place where the developer can:

- leverage user profile and behavioral data
- lookup company catalog data
- build campaign configuration and use provided data
- select and pull Einstein Recipe recommendations

to output transformed payload containing everything that is needed for a unique experience for each customer.

<Image img={purpose} alt='Graph displaying the purpose of Serverside code as a centre collecting data, configuration and recommendations to output personalisation payload'/>

## IS Serverside Code Basics

All above things are done within Serverside Code tab of the Interaction Studio Template creation UI with TypeScript programming language and built-in functions. Don't worry if you don't know TypeScript - basic knowledge of modern JavaScript is enough to create good templates.

:::note You Should Know

Open Time Email Campaigns are using different, older system. I covered its details in a [separate guide](./is-open-time-email.mdx).

:::

When you open the Serverside Code tab in a new Template creation screen for Web, Serverside or Triggered Campaign within the Marketing Cloud Personalization, you will be greeted by a bit intimidating interface. Let's start by breaking it down section by section:

1. The middle pane contains your whole TypeScript code responsible for all the magic happening on the serverside.
2. Within the middle section (1) you will see two sections. First one is responsible for defining the Campaign configuration form. In the screenshot below you can see a `header` field being defined as a `string` and decorated with custom title.
3. The form definitions you develop (2) will be available for a preview on the left pane. This section not only allows you to see how the Campaign Configuration screen will look like, but also try filling it in to see the interactions.
4. Coming back to the middle section (1), below the configuration form definitions (2) you will find the `run` function with `context` being passed as an argument. This is part where you can optionally transform or enrich the data captured from the configuration form. The `context` provided to the function contains triggering event data as well as access to a lot of helper functions that can bring your template to the next level. You can also add additional properties (for example, debugging details) to the returned object to make them available in the payload (5).
5. The bottom part of the right pane displays the Payload Preview. It is updated in real-time as you write your TypeScript (1) or change the configuration (3). it is great way to validate whether you are getting outcome you need.
6. If your template leverages user or catalog data (for example, user attributes for personalisation or anchored recipes) to see the proper payload you will need to provide example data. Top section of the right pane lets you do it. You can provide the IDs and see the payload (5) adapt to simulated scenario.

<Image img={templateUi} alt='Interaction Studio Serverside Template UI screenshot'/>

The final outcome of your work in this tab is the personalised payload (5). Depending on the type of Campaign this template is for it will either be delivered as is (Serverside), put into a Data Extension (Triggered Campaign) or be available to leverage for logic in Clientside Code and experience in Handlebars tabs (Web Campaign).

:::note You Should Know

If you don't see `experience` or `campaign` in the payload object (5), it means there is a bug in your template code (1).

If you don't see the configuration form preview (3) updates despite making changes in the serverside code (1) it probably froze. Check whether you are still logged in to the Interaction Studio (MCP session length is shorter to that of SFMC). If yes, cut (`ctrl`/`cmd` + `x`) your whole serverside code, provide any symbol (like `a`) to overwrite the cache and replace it back by pasting the code (`ctrl`/`cmd` + `v`).

:::

## Writing Serverside Code

As mwentioned above, when you create new Web, Serverside or Triggered Campaign Template and view the Serverside Code tab, you will get a very short and simple code snippet:

```ts
export class NewTemplate implements CampaignTemplateComponent {

    @title("Example Field")
    header: string;

    run(context: CampaignComponentContext) {
        return {};
    }

}
```

There is a collection of much more complex [Global Templates available](https://github.com/evergage/evergage-global-templates/tree/master) that are great starting points for building real campaigns, but here we will start with the base snippet and build up from it for learning purposes.

There are three key parts of that snippet:

```ts {3-5,7-8,10}
export class NewTemplate implements CampaignTemplateComponent {

    // 1: field configuraiton
    @title("Example Field")
    header: string;

    run(context: CampaignComponentContext) {
        // 2: run block

        return {}; // 3: return statement
    }
}
```

1. Field Configuration

The field configuration let's you add properties that will become part of the campaign configuration form used by marketers to set the experiences. This is the main data input and all properties you set here will be passed directly to the campaign response.

2. Run Block

Run block has access to the context - triggering event details and Interaction Studio data. It can also pull information configured in the properties by the marketer. With all of this you can use it to enrich and transform the data that will be returned by the campaign.

3. Return Statement

Return statement within the run block lets you add custom properties to the final campaign payload. Whatever you add to the returned object will be made available along with the properties from field configuration section.

:::note You Should Know

Run block execution works differently during the template creation and in the campaign configuration. When marketer configures the campaign, the changes executed within the run section will be applied - this may lead to content changes or even removal of configuration parts. You shouldn't transform the data in the fields directly, but rather do it on new variables:

```ts {8,10} title="Transform content using new variable"
export class PersonalizedOverlay implements CampaignTemplateComponent {

    @title("Personalized Header")
    @subtitle("Use {firstName} to insert first name personalization")
    initialHeader: string;

    run(context: CampaignComponentContext) {
        let header = this.initialHeader.replace(/{firstName}/g, context.user.attributes?.firstName);

        return {header};
    }
}
```

This way the configured field will stay as it is, but in the final campaign payload you will also have the transformed variable for use.

Keep this in mind when you have to provide a payload accoridng to a specification (f.e. in Serverside Campaign Tempalate). If you want to make any transformations to a manual input, add some prefix to the property in the field configuration section (f.e. `initial`) and output the expected name only through the return statement of the run block as shown in the snippet above.

:::


### Basic properties

### Complex properties

### Arrays

### Default values

### Options

### Decorators

### Recommendations

### Context

### Imports

## Best Practices

Don't use final needed in payload values as field names. It will make any transformations/fitlerings a pain. Use different value and normalize in return statement.